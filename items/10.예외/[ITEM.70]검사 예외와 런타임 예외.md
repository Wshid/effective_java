## [ITEM.70] 검사 예외와 런타임 예외

### 문제 상황을 알리는 타입(throwable)
- 3가지 방식
  - 검사 예외, 런타임 예외, 에러
- 각각의 방법을 언제 사용해야 하는지

### 검사 예외의 사용
- **호출하는 쪽**에서 **복구하리라**라는 상황이면 사용
- **검사**와 **비검사 예외**를 구분하는 기본 규칙
- **검사 예외**를 던지게 되면
  - 호출자가 그 예외를 `catch`로 잡아 처리하거나
  - 더 바깥으로 전파하도록 강제하게 됨
- **메서드 선언**에 포함된 **검사 예외** 각각은
  - 그 메서드를 호출했을 때, 발생할 수 있는 유력한 결과임을 **API 사용자**에게 알려주는 것
  - API 설계자는, **API 사용자**에게 **검사 예외**를 던져 주어
    - 그 상황에서 **회복하라**라고 요구한 것
  - 물론 사용자는, 예외를 잡고 별다른 조치를 취하지 않을 수 있으나, 좋지 않은 생각(ITEM.77)
  
### 비검사 throwable
- **런타임 예외**와 **에러**
- 둘 다 동작측면에서는 **다르지 않음**
- 프로그램에서 잡을 필요가 없거나,
  - 통상적으로 **잡지 말아야 함**
- 프로그램에서 **비검사 예외**를 던졌다는 것은
  - **복구**가 **불가능**하거나,
  - 더 실행해도 득보다 **실**이 많다는 의미
- 이런 `throwable`을 잡지 않은 스레드는
  - 적절한 **오류 메세지**를 뱉으며 **중단**

### 런타임 예외의 사용
- 프로그래밍 **오류**를 나타낼 때 사용
- 런타임 예외의 대부분은
  - **전제 조건**을 만족하지 못할 때 발생
- 전제조건 위배란
  - 단순히 C가 `API 명세`에 기록된 제약을 **지키지 못함**을 의미
  - 배열의 인덱스는 `0 ~ size-1` 등..
    - `ArrayIndexOutOfBoundsException` : 위 전제 조건이 지켜지지 않음을 의미

### 복구할 수 있는 상황이라는 판단
- **복구할 수 있는 상황**인지 **프로그래밍 오류**인지 명확히 구분되지 않음
- 예시 : 자원 고갈
  - 말도 안되는 크기의 배열을 할당해서 발생한 **프로그래밍 오류** 이거나
  - 진짜로 자원이 부족해서 발생한 **문제**
  - 자원이 일시적으로 부족했던 상황이라면, 충분히 복구할 수 있는 상황
  - 해당 자원 고갈 상황이 복구 가능한지는,
    - **API 설계자의 판단에 달림**
- **복구 가능**하다고 믿는다면 **검사 예외**를, 그렇지 않다면 **런타임 예외** 사용
- 확신하기 어렵다면, **비검사 예외**를 선택하는 편이 좋음(ITEM.71)

### 에러의 사용
- `JVM`이 자원 부족, 불변식 깨짐 등
  - **더 이상 수행을 계속할 수 없는 상황**을 나타낼 때 사용
- 자바 언어 명세가 요구하는 것은 아니지만,
  - 업계에 널리 퍼진 규약,
  - `Error` 클래스를 상속해 하위 클래스를 만드는 일은 **자제**
- 직접 구현하는 비검사 `throwable`은 모두
  - `RuntimeException`의 하위 클래스이어야 함(직/간접 포함)
- `Error`는 상속하지 말아야 할 뿐 아니라,
  - `throw`로 직접 던지는 일도 없어야 함(`AssertionError`)는 예외

### Exception, RuntimeException, Error를 상속하지 않는 throwable
- 만들기가 가능
- 자바 언어 명세에, 이런 `throwable`를 직접 다루지는 않으나,
  - 암묵적으로 **일반적인 검사 예외**(`Exception`의 하위 클래스 중 `RuntimeException`을 상속하지 않음)처럼 다룸
- 위 `throwable`의 사용처는 없음, **절대 사용하지 말 것**
- `throwable`은 **정상적인 검사 예외**보다 나을 게 없으며,
  - `API 사용자`를 혼란스럽게 함

### 예외의 메서드
- API 설계자들도 **예외** 역시 **어떤 메서드**라도 정의할 수 있는
  - 완벽한 객체임을 잊곤 함
- **예외의 메서드**는
  - 주로 그 **예외를 일으킨 상황에 관한 정보를 코드 형태로 전달**하는데에 쓰임
- 이런 메서드가 없다면
  - 프로그래머들은 오류 메세지를 **파싱**하여 정보를 빼내야 함
  - 매우 나쁜 습관(ITEM.12)
- `throwable` 클래스들은 대부분 **오류 메세지 포맷**을 상세히 기술하지 않음
  - 이는 `JVM`이나 릴리스에 따라 **포맷**이 달라질 수 있음을 시사
- 따라서 **메시지 문자열**을 파싱해 얻은 코드는
  - 깨지기 쉽고, 다른 환경에서 동작하지 않을 가능성 존재

### 검사 예외의 발생
- 일반적으로 **복구할 수 있는 조건**일 때 발생
- 따라서 **호출자**가 **예외 상황**에서 벗어나는데
  - 필요한 정보를 알려주는 **메서드**를 함께 제공하는 것이 중요
- 예시
  - 쇼핑몰에서 물건 구입, 카드 잔고 부족하여 검사 예외 발생
  - 이 예외에서, 잔고가 얼마나 부족한지를 알려주는 **접근자 메서드**를 제공해야 함
  - ITEM.75에서 더 자세히 설명

### 정리
- 검사 예외 : **복구 가능**한 상황
- 비검사 예외 : 프로그래밍 오류
- 확실하지 않을 경우 **비검사 예외** 사용
- **검사 예외**도 아니고 **런타임 예외**도 아닌
  - `throwable`은 정의하지 말 것
- **검사 예외**일 경우
  - 복구에 필요한 정보를 알려주는 **메서드**를 함께 제공