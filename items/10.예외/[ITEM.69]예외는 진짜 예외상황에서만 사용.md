## [ITEM.69] 예외는 진짜 예외 상황에서만 사용

### 예외를 잘못 사용한 예시
```java
try {
  int i = 0;
  while(true)
    range[i++].climb();
} catch ( ArrayIndexOutOfBoundsException e) {
  ...
}
```
- 전혀 **직관적**이지 않음(ITEM.67)
- 배열의 원소를 순회하는 코드
  - 무한루프를 돌다가,
  - 배열의 끝에 도달했을 때, `ArrayIndexOutOfBoundsException` 발생하여 끝남
- 위 코드보다 개선된 코드
  ```java
  for (Mountain m : range)
    m.climb();
  ```
- **예외**를 사용하여 종료한 이유?
  - 잘못된 추론을 근거로 **성능**을 높이려 함
- `JVM`은 배열에 접근할 때마다 경계를 넘지 않도록 검사,
  - 일반적인 반복문도, **배열 경계**에 도달하면 종료함
  - 이 검사를 **반복문**에도 명시하면,
    - 같은 일이 **중복**되기 때문에 하나를 **생략**한 것

### 코드가 잘못된 이유(3)
- **예외**는 **예외 상황**에 쓸 용도로 설계됨
  - JVM 구현자 입장에서는 **명확한 검사**만큼 빠르게 만들어야할 **동기**가 약함
    - 최적화에 신경 쓰지 않았을 가능성이 큼
- 코드를 `try-catch` 블록 안에 넣으면
  - JVM이 적용할 수 있는 **최적화**가 **제한됨**
- 배열을 순회하는 **표준 관용구**는
  - 앞에서 논의한 **중복 검사**를 하지 않음
  - JVM이 알아서 **최적화**를 수행

### 예외를 함부로 사용한 부작용
- 실제 **예외**를 사용한 코드가
  - **표준 관용구**보다 훨씬 느림
- 단순히 가독성/성능 저하에서 끝나지 않음
- 제대로 동작하지 않을 가능성 존재
  - 반복문 안에 버그가 숨어 있으면, **흐름 제어**에 쓰인 예외가
    - 해당 버그를 숨겨, **디버깅**을 어렵게 할 수 있음
- 반복문 몸체에서 호출한 **메서드**가
  - 내부에서 관련없는 배열을 사용하다 `ArrayIndexOutOfBoundsException