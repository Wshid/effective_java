## [ITEM.69] 예외는 진짜 예외 상황에서만 사용

### 예외를 잘못 사용한 예시
```java
try {
  int i = 0;
  while(true)
    range[i++].climb();
} catch ( ArrayIndexOutOfBoundsException e) {
  ...
}
```
- 전혀 **직관적**이지 않음(ITEM.67)
- 배열의 원소를 순회하는 코드
  - 무한루프를 돌다가,
  - 배열의 끝에 도달했을 때, `ArrayIndexOutOfBoundsException` 발생하여 끝남
- 위 코드보다 개선된 코드
  ```java
  for (Mountain m : range)
    m.climb();
  ```
- **예외**를 사용하여 종료한 이유?
  - 잘못된 추론을 근거로 **성능**을 높이려 함
- `JVM`은 배열에 접근할 때마다 경계를 넘지 않도록 검사,
  - 일반적인 반복문도, **배열 경계**에 도달하면 종료함
  - 이 검사를 **반복문**에도 명시하면,
    - 같은 일이 **중복**되기 때문에 하나를 **생략**한 것

### 코드가 잘못된 이유(3)
- **예외**는 **예외 상황**에 쓸 용도로 설계됨
  - JVM 구현자 입장에서는 **명확한 검사**만큼 빠르게 만들어야할 **동기**가 약함
    - 최적화에 신경 쓰지 않았을 가능성이 큼
- 코드를 `try-catch` 블록 안에 넣으면
  - JVM이 적용할 수 있는 **최적화**가 **제한됨**
- 배열을 순회하는 **표준 관용구**는
  - 앞에서 논의한 **중복 검사**를 하지 않음
  - JVM이 알아서 **최적화**를 수행

### 예외를 함부로 사용한 부작용
- 실제 **예외**를 사용한 코드가
  - **표준 관용구**보다 훨씬 느림
- 단순히 가독성/성능 저하에서 끝나지 않음
- 제대로 동작하지 않을 가능성 존재
  - 반복문 안에 버그가 숨어 있으면, **흐름 제어**에 쓰인 예외가
    - 해당 버그를 숨겨, **디버깅**을 어렵게 할 수 있음
- 반복문 몸체에서 호출한 **메서드**가
  - 내부에서 관련없는 배열을 사용하다 `ArrayIndexOutOfBoundsException`을 발생시켰을 경우
  - **표준 관용구**였다면, 이 버그는 예외를 잡지 않고
    - 스택 추적 정보만 남기고
    - 스레드를 **즉각 종료**
- 예외를 사용한 반복문은
  - 버그 때문에 발생한 엉뚱한 예외를, **정상적인 반복문 종료 상황**으로 인지

### 예외를 바르게 사용하기
- 오직 **예외 상황**에서만 사용
- 절대 일상적인 **제어 흐름용으로 사용하지 말 것**
- 표준적이고, 쉽게 이해되는 관용구를 사용하고,
  - 성능 개선을 목적으로 과하게 머리 쓴 기법은 자제할 것
- 실제 성능이 좋아지더라도,
  - 자바 플랫폼이 꾸준히 개선되고 있으니,
  - 최적화로 얻은 상대적인 성능 우위가, 오래가지 않을 수 있음
- 과하게 영리한 기법에 숨겨진 미묘한 버그의 폐해와
  - 어려워진 유지보수 문제는 계속 지속될 것

### API 설계에 반영된 규칙
- 잘 설계된 API라면
  - C가 **정상적인 제어 흐름**에서 **예외**를 사용할 일이 없게 해야 함
- 특정 상태에서만 호출할 수 있는
  - **상태 의존적** 메서드를 제공하는 클래스는
  - **상태 검사** 메서드도 **함께 제공**해야 함
- `Iterator` 인터페이스의
  - `next`와 `hasNext`가
  - 각각 **상태 의존적 메서드**와, **상태 검사** 메서드에 해당
- 별도의 **상태 검사 메서드** 덕분에
  - 다음과 같은 `for` 관용구 사용 가능
  - `for-each`도 내부적으로 `hasNext`를 사용
  ```java
  for (Iterator<Foo> i = collection.iterator(); i.hasNext();) {
    Foo foo = i.next();
    ...
  }
  ```
- 만약 `Iterator`가 `hasNext`를 제공하지 않았다면, C가 대신 수행해야 함
  ```java
  try {
    Iterator<Foo> i = collection.iterator();
    while(true) {
      Foo foo = i.next();
      ...
    }
  } catch (NoSuchElementException e) {
    ...
  }
  ```
- 반복문에 **예외**를 사용하면, 헷갈리며 속도도 느리고,
  - 엉뚱한 곳에서 발생한 버그가 숨겨지기도 함

### 상태 검사 메서드 대신 사용할 수 있는 선택지
- 올바르지 않은 상태일 때 **빈 옵셔널**(ITEM.55)
  - 또는 `null` 같은 특수한 값을 반환
- 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침(2)
  - 외부 동기화 없이, 여러 스레드가 **동시에** 접근할 수 있거나
    - 외부 요인으로 상태가 **변할 수 있다면**
      - **옵셔널**이나 **특정 값**을 사용 함
    - **상태 검사 메서드**와 **상태 의존적 메서드 호출** 사이에
      - 객체 상태가 변할 수 있기 때문
  - 성능이 중요한 상황에서
    - **상태 검사 메서드**가 **상태 의존적 메서드**의 작업 일부를
      - **중복 수행** 한다면 **옵셔널**이나 **특정 값** 사용
- 이외 경우엔 **상태 검사 메서드 방식**이 더 나음
  - 가독성이 더 좋고, 잘못 사용했을 때 발견하기 쉬움
  - **상태 검사 메서드** 호출을 깜빡 했을 경우,
    - **상태 의존적 메서드**가 예외를 던져 **버그**가 발견될 것
- 반면, **특정 값**은
  - 검사하지 않고, 지나쳐도 발견하기가 어려움
  - 옵셔널에는 해당하지 않는 문제

### 정리
- **예외**는 **예외 상황**에서 쓸 의도로 설계됨
- 정상적인 제어흐름에서 사용하면 X
  - 이를 프로그래머에게 강요하는 API 제작도 X

