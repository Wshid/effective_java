## [ITEM.83] 지연 초기화는 신중히 사용

### lazy initialization
- 필드의 **초기화** 시점을 그 값이 처음 필요할때까지 늦추는 방법
- 그 값이 전혀 쓰이지 않게 된다면
  - **초기화**도 일어나지 않음
- 이 기법은 **정적 필드**와 **인스턴스 필드"** 모두에 사용 가능
- **지연 초기화**는 주로 **최적화** 용도로 사용되지만,
  - 클래스와 인스턴스 초기와 때 발생하는 **위험한 순환 문제**를 해결하려는 효과가 있음

### 필요할 때 까지 사용하지 말 것
- 지연 초기화의 최선의 종런
  - 필요할 때까지는 하지 말라(ITEM.67)
- 양날의 검
  - 클래스 혹은 인스턴스 **생성 시의 초기화 비용**은 줄어들지만,
  - 지연 초기화하는 필드에 **접근하는 비용**은 커진다
- 지연 초기화하려는 필드들 중,
  - 결국 **초기화**가 이뤄지는 비율에 따라,
  - 실제 초기화에 드는 비용에 따라,
  - 초기화된 각 필드를 **얼마나 호출**하느냐에 따라
  - 지연 초기화가 실제로는 성능을 **느려지게**할 수도 있음

### 지연 초기화가 필요한 상황
- 해당 클래스의 인스턴스 중,
  - 그 필드를 사용하는 **인스턴스 비율**이 낮은 반면,
  - 그 필드를 **초기화하는 비용**이 크다면
    - 지연 초기화가 제 역할을 해준다.
- 그런 상황임을 확인할 수 있는 유일한 방법은
  - **지연 초기화**의 적용 전/후의 성능을 측정해 보는 것

### 멀티 스레드 환경에서의 어려움
- 지연 초기화 하기 어려운 상황
- 지연 초기화하는 필드를
  - **둘 이상의 스레드**가 공유한다면,
  - 어떤 형태로든 반드시 **동기화**해야함
- 그렇지 않으면 심각한 **버그**로 이어질 것(ITEM.78)
- 참고로 이번 아이템에서 다루는 모든 초기화 기법은 모두 **스레드 안전**

### 대부분의 상황, 일반적인 초기화가 더 나은 선택
- 대부분의 상황에서는 **일반적인 초기화**가 지연 초기화 보다 나음
- `final` 한정자를 사용했음에 주의
  - 인스턴스 필드를 초기화하는 일반적인 방법
    ```java
    private final FieldType field = computeFieldValue();
    ```
- **지연 초기화**가 **초기화 순환성**(initialization circularity)를 깨뜨릴 것 같으면,
  - `synchronized`접근자를 사용할 것
- 인스턴스 필드의 지연 초기화 - synchronized 접근자
  ```java
  private FieldType field;

  private synchronized FieldType getField() {
    if (field == null)
      field = computeFieldValue();
    return field;
  }
  ```
- 이상의 두 관용구(보통의 초기화와 `synchronized` 접근자를 사용한 지연 초기화)
  - **정적 필드**에도 똑같이 적용됨
  - **필드**와 **접근자 메서드 선언**에 `static` 한정자를 추가해야 함

### 성능 이유의 정적 필드 지연 초기화
- **성능** 때문에 **정적 필드**를 **지연 초기화**해야 한다면,
  - **지연 초기화 홀더 클래스**(lazy initialization holder class) 관용구를 사용하기
- 클래스는, 클래스가 처음 쓰일 때 비로소 **초기화** 된다는 특성을 이용한 관용구

### 정적 필드용 지연 초기화 홀더 클래스 관용구
- 코드
  ```java
  private static class FieldHolder {
    static final FieldType field = computeFieldValue();
  }

  private static FieldType getField() { return FieldHolder.field; }
  ```
- `getField`가 처음 호출되는 순간, `FieldHolder.field`가 처음 읽히면서,
  - 비로소 `FieldHolder` 클래스 초기화를 촉발함
- 이 관용구의 장점은
  - `getField` 메서드가 **필드**에 접근하면서, **동기화**를 하지 않음
    - **성능이 느려질 이유가 없음**
- 일반적인 VM은
  - 오직 **클래스**를 **초기화**할 때만 **필드 접근**을 동기화할 것
  - **클래스 초기화**가 끝난 후에는
    - VM이 동기화 코드를 제거하여
    - 그 다음부터는 아무런 검사나 동기화 없이 필드에 접근하게 된다.

### 성능 이유의 인스턴스 필드 지연 초기화
- 성능 때문에 **인스턴스 필드**를 지연 초기화 해야 한다면
  - **이중 검사**(double-check) 관용구 사용
- 이 관용구는
  - **초기화된 필드**에 접근할 때의 **동기화 비용**을 없애줌(ITEM.79)
- 필드의 값을 두번 검사하는 방식으로
  - 한 번은, **동기화 없이 검사**하고,
  - 필드가 아직 초기화되지 않았다면, 두 번째는 **동기화**하여 검사한다.
- 두번째 검사에서도 필드가 초기화 되지 않았을 때만, **필드를 초기화**
- 필드가 초기화된 후로는 **동기화**하지 않으므로
  - 해당 필드는 반드시 `volatile`로 선언해야 함(ITEM.78)

### 인스턴스 필드 지연 초기화용 이중검사 관용구
- 코드
  ```java
  private volatile FieldType field;

  private FieldType getField() {
    FieldType result = field;
    if (result != null) { // 첫 번째 검사 (락을 사용하지 않음)
      return result;
    }

    synchronized(this) {
      if (field == null) // 두 번째 검사 (락 사용)
        field = computeFieldValue();
      return field
    }
  }
  ```
- volatile : https://nesoy.github.io/articles/2018-06/Java-volatile
  - 멀티 쓰레드 환경에서, 자바 변수를 항상 cpu cache가 아닌 main memory에서 read/write 하도록 함
- `result`라는 지역 변수가 필요한 이유
  - 이 변수는 필드가 **이미 초기화**된 상황(일반적인 상황)에서는
    - 그 필드를 한 번만 읽도록 보장하는 역할
- 반드시 필요하지는 않지만,
  - **성능**을 높여 주고,
  - **저수준 동시성 프로그래밍**에 표준적으로 적용되는 우아한 방법
- 컴퓨터 마다 다를수 있겠으나,
  - 필자의 경우 지역변수를 사용하지 않을 때보다 **1.4**배 빠르게 동작

### 이중검사 사용시 유의점
- 이중검사를 **정적 필드**에도 적용할 수 있으나, 굳이 그럴 이유가 없음
  - 이보다는 **지연 초기화 홀더 클래스**방식이 좋음

### 이중검사의 변종 - 단일검사(single-check)
- 반복해서 초기화해도 상관 없는 **인스턴스 필드**를 지연 초기화 할 때,
  - 이중검사에서 두 번째 검사를 생략할 수 있음
- 관용구 코드
  ```java
  private volatile FieldType field;

  private FieldType getField() {
    FieldType  result = field;
    if (reslut == null)
      field = result = computeFieldValue();
    return result;
  }
  ```
  - 필드는 여전히 `volatile`로 선언한 상황

### 초기화 기법 - 기본 타입/객체 참조
- 이번 ITEM에서 이야기한 모든 초기화 기법은
  - **기본 타입 필드**와 **객체 참조 필드**에 모두 적용 가능
- **이중검사**와 **단일검사** 관용구를 **수치 기본 타입 필드**에 적용한다면
  - 필드의 값을 `null` 대신
  - 숫자 기본 타입변수의 기본값인 `0`과 비교하면 됨

### 이중검사의 변종 - 짜릿한 단일검사(racy single-check)
- 모든 스레드가 필드의 값을 다시 계산해도 상관없고,
  - 필드의 타입이 `long`과 `double`을 제외한 **다른 기본 타입**이라면,
  - **단일검사의 필드 선언**에서 `volatile` 한정자를 제거해도 됨
  - 이를 **짜릿한 단일 검사**(racy single-check) 관용구라 불림
- 어떤 환경에서는 **필드 접근 속도**를 높여주지만,
  - 초기화가 **스레드**당 최대 한 번 더 이루어질 수 있음
- 이례적인 기법으로, 보통은 사용하지 않음

### 정리
- 대부분의 필드는 지연시키지 말고, 바로 초기화 하여야 함
- 성능 때문에 혹은 **위험한 초기화 순환**을 막기 위해 꼭 지연초기화를 사용해야 한다면,
  - 올바른 지연 초기화 기법을 사용해야 함
- **인스턴스 필드**에는 **이중검사 관용구
- **정적 필드**에는 **지연 초기화 홀더 클래스 관용구**를 사용
- 반복해 초기화해도 괜찮은 **인스턴스 필드**에는 **단일검사 관용구**도 사용해도 좋음 