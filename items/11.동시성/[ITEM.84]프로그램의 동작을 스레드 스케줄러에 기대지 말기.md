## [ITEM.84] 프로그램의 동작을 스레드 스케줄러에 기대지 말기

### 스케줄링 정책
- 여러 **스레드**가 실행중이면 OS의 **스레드 스케줄러**가
  - 얼마나 오래 실행할지 결정
- 정상적인 OS라면
  - 위 작업을 공정하게 수행하지만
  - 구체적인 스케줄링 정책은 `OS`마다 다를 수 있음
- 잘 작성된 프로그램이라면
  - 이 정책에 좌지우지 되서는 안됨
- **정확성**이나 **성능**이 **스레드 스케줄러**에 따라 달라지는 프로그램이라면
  - **다른 플랫폼에 이식하기 어려움**

### 이식성 좋은 프로그램 작성
- 견고하고 빠르고, 이식성 좋은 프로그램을 작성하는 가장 좋은 방법은,
  - 실행 가능한 **스레드의 평균적인 수**를 **프로세서 수**보다 지나치게 많아지지 않도록 하는 것
- 그래야, 스레드 스케줄러가 고민할 부분이 적어듦
- **실행 준비**가 된 스레드들은
  - 맡은 작업을 완료할때까지 **계속 실행**되도록 만들기
- 이런 프로그램이라면, **스레드 스케줄링 정책**이 아주 상이한 시스템이어도
  - 동작이 크게 달라지지 않음
- **실행 가능한 스레드 수**와 **전체 스레드 수**는 구분지어야 함
- **전체 스레드 수**는 훨씬 많을 수 있으며,
  - **대기 중인 스레드**는 실행 가능하지 않음

### 실행 가능한 스레드 수를 적게 유지하는 주요 기법
- 실행 가능한 스레드 수를 적게 유지하는 주요 기법은
  - 각 스레드가 무언가 유용한 작업을 **완료**한 후에는
  - 다음 일거리가 생길 때까지 **대기**하도록 하는 것
- **스레드는 당장 처리할 작업이 없다면, 실행되서는 안됨**
- 실행자 프레임워크(ITEM.80) 예시로,
  - **스레드 풀 크기**를 적절히 설정하고,
  - 작업은 **짧게 유지**하면 됨
- 너무 짧게 유지할경우, 오히려 **작업 분배 비용**이 커져
  - 성능이 떨어질 수 있음

### busy waiting
- 스레드는 절대 바쁜 대기(busy waiting) 상태가 되면 X
- **공유 객체**의 상태가 바뀔 때까지
  - 쉬지 않고 검사해서는 X
- **바쁜 대기**는
  - 스레드 스케줄러 **변덕**에 취약할 뿐 아니라,
  - 프로세서에 큰 부담을 주어, 다른 유용한 **작업**이 실행될 기회를 박탈함

### `CountDownLatch`의 잘못된 구현 - busy waiting
- 코드
  ```java
  public class SlowCountDownLatch {
    private int count;

    public SlowCountDownLatch(int count) {
      if (count < 0)
        throw new IllegalArgumentException(count + " <0");
      this.count = count;
    }

    public void await() {
      while(true) {
        synchronized(this) {
          if(count == 0)
            return;
        }
      }
    }

    public synchronized void countDown() {
      if (count != 0)
        count--;
    }
  }
  ```
- latch를 기다리는 스레드를 `1,000`개를 만들어
  - 자바의 `CountDownLatch`와 비교했을 때, **10배**정도가 느렸다고 함
- 하나 이상의 **스레드**가 필요도 없이
  - 실행 가능한 상태인 시스템은
  - 흔하게 확인될 수 있으며,
  - **성능**과 **이식성**이 떨어질 수 있음

### Thread.yield의 오용
- 특정 스레드가, 다른 스레드들과 비교하여
  - `CPU 시간`을 충분히 얻지 못해, 간신히 돌아가는 프로그램을 보더라도
  - `Thread.yield`를 써서 문제를 해결하지 말 것
- 증상이 어느정도 호전될 수도 있으나,
  - **이식성**은 그렇지 않음
- 처음 JVM에서 성능을 높여준 `yield`가
  - 두번째 `JVM`에서는 아무 효과가 없고,
  - 세번째 에서는 오히려 느려질 수 있음
- `Thread.yield`는 **테스트할 수단**이 없음
- 차라리 `app` 구조를 바꿔,
  - **동시에 실행 가능한 스레드의 수**가 적어지도록 조치할 것

### 스레드 수 조정 및 sideEffect
- 위 상황에서, **스레드 우선순위**를 조절하는 방법도 있으나,
  - 역시 위험이 따름
- **스레드 우선순위**는 자바에서 **이식성**이 가장 나쁜 특성
- 스레드 몇 개의 우선순위를 조율해서, app의 **반응 속도**를 높이는 것도 타당할 수 있겠으나,
  - 정말 그래야할 상황은 **드물고**, **이식성이 떨어짐**
- 심각한 **응답 불가 문제**를
  - **스레드 우선순위**로 해결하려는 것은, 절대 합리적이지 않음
- 진짜 원인을 찾아 수정하기 전까지, 위와 같은 문제가 **반복**될 것

### 정리
- 프로그램의 동작을 **스레드 스케줄러**에 기대지 말 것
  - **견고성**과 **이식성**을 모두 해치는 행위
- `Thread.yield`의 스레드 우선순위에 의존해서도 X
- 위 기능들은 모두 **스레드 스케줄러**에 제공하는 힌트일 뿐
- **스레드 우선순위**는
  - 이미 잘 동작하는 프로그램의 **서비스 품질 향상**에서 쓰일 수 있으나,
  - 간신히 동작하는 프로그램을 **고치는 용도**로 사용해서는 X