## [ITEM.82] 스레드 안전성 수준을 문서화

### 동시 호출시의 규약
- 한 메서드를 **여러 스레드**가 동시 호출할 때
  - 그 메서드가 어떻게 동작하느냐는
  - 해당 클래스와 이를 사용하는 C사이의 **중요한 계약**
- API문서에서 아무런 언급도 없으면
  - 그 클래스 사용자는 나름의 **가정**을 해야함
- 그 가정이 틀리면
  - C 프로그램은 **동기화**를 충분히 하지 못하거나(ITEM.78)
  - 지나친 동기화를 한(ITEM.79) 상태이며
    - 두 상황 모두, **심각한 오류**로 이어질 수 있음

### synchronized는 스레드 안전하다? - 1
- API 문서에 `synchronized`한정자가 보이는 메서드는
  - **스레드 안전**하다는 이야기가 있으나,
  - 몇가지 면에서 **틀림**
- `javadoc`이 기본 옵션에서 생성한 API 문서에는
  - `synchronized` 한정자가 포함되지 않음
- 메서드 선언에 `synchronized` 한정자를 선언할지는
  - **구현 이슈**일 뿐, `API`에 속하지 않음
- 따라서, 이것만으로는
  - 그 메서드가 **스레드 안전**하다고 믿기 어려움

### synchronized는 스레드 안전하다? - 2
- `synchronized` 유무로 **스레드 안전성**을 알 수 있다는 주장은
  - **스레드 안전성**은 '모 아니면 도'라는 **오해**에 뿌리를 둔 것
- 하지만 **스레드 안전성**에도 **수준**이 존재
- **멀티 스레드** 환경에서도
  - `API`를 안전하게 사용하게 하려면,
  - **클래스**가 지원하는 **스레드 안전성 수준**을 정확히 **명시** 해야 함

### 스레드 안전성 수준
- 완벽하진 않으나 일반적인 상황을 포괄함
- 아래의 분류는 스레드 적대적을 제외하고
  - **자바 병렬 프로그래밍**의 부록 `A`에 나오는
  - 스레드 안전성 애너테이션(`@Immutable`, `@ThreadSafe`, `@NotThreadSafe`)와 대략 일치
- **무조건적 스레드 안전**과 **조건부 스레드 안전**은 모두
  - `@ThreadSafe` 애너테이션에 속함 

#### 불변(immutable)
- 이 클래스의 **인스턴스**는 마치 **상수**와 같아서, **외부 동기화가 필요 없음**
- `String`, `Long`, `BigInteger`(ITEM.7) 등이 대표적

#### 무조건적 스레드 안전(unconditionally thread-safe)
- 이 클래스의 인스턴스는 **수정될 수 있으나**
  - 내부에서 충분히 **동기화**하여, 별도의 **외부 동기화** 없이
    - 동시에 사용해도 안전
- `AtomicLong`, `ConcurrentHashMap`이 여기에 속함

#### 조건부 스레드 안전(conditionally thread-sfae)
- 무조건적 스레드 안전과 동일하나,
  - **일부 메서드**는 동시에 사용하려면 **외부 동기화**가 필요
- `Collections.synchronized` 래퍼 매서드가 반환한 **컬렉션**이 여기에 속함
- 이 컬렉션이 반환한 **반복자**는 외부에서 **동기화**해야 함

#### 스레드 안전하지 않음(not thread-safe)
- 이 클래스의 인스턴스는 **수정 될 수 있음**
- 동시에 사용하려면,
  - 각각의 혹은 일련의 **메서드 호출**을 `C`가 선택한 **외부 동기화 매커니즘**으로 감싸야 함
- `ArrayList`, `HashMap`과 같은 **기본 컬렉션**이 여기에 속함

#### 스레드 적대적(thread-hostile)
- 이 클래스는 **모든 메서드 호출**을 **외부 동기화**로 감싸더라도
  - **멀티 스레드 환경**에서 안전하지 않음
- 이 수준의 클래스는
  - 일반적으로 **정적 데이터**를 아무런 동기화 없이 수정
- 이런 클래스를 고의로 만드는 사람은 없겠으나,
  - **동시성**을 고려하지 않고 작성하다보면 우연히 만들어질 수 있음
- 스레드 적대적으로 밝혀진 클래스나 메서드는
  - 일반적으로 문제를 고쳐 **재배포**하거나 `deprecated API`로 지정됨
- 426쪽에서 설명했듯이,
  - ITEM.78의 `generateSerialNumber` 메서드에서 **내부 동기화**를 생략하게 되면
    - 스레드 적대적이게 됨

### 조건부 스레드 안전의 유의점
- 조건부 스레드 안전한 클래스는 **주의하여 문서화**
- 어떤 **순서**로 호출할 때, **외부 동기화**가 필요한지
  - 그리고 그 순서로 호출하려면 어떤 **락**혹은
  - 드물게 **락**들을 얻어야하는지 알려줘야 함
- 일반적으로 **인스턴스 자체**를 **락**으로 얻지만, 예외도 존재
- `Collections.synchronizedMap`의 API 문서에는 다음과 같은 내용 존재
  ```java
  synchronizedMap이 반환한 맵의 컬렉션 뷰를 순회하려면 반드시 그 맵을 락으로 사용해 수동으로 동기화

  Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
  Set<K> s = m.keySet(); // 동기화 블록 밖에 있어도 됨
  ...
  synchronized(m) { // s가 아닌 m을 사용해 동기화해야 한다
    for (K key : s)
      key.f();
  }

  이대로 하지 않을경우, 동작을 예측할 수 없음
  ```

  ### 메서드에 주석 기입
  - **클래스 스레드 안전성***은 보통 클래스의 **문서화 주석**에 기재하지만
    - 독특한 특성의 **메서드**라면 **해당 메서드의 주석**에 기재해야 함
  - **열거 타입**은 굳이 **불변**이라고 쓰지 않아도 됨
  - **반환 타입**만으로는 명확히 알 수 없는 **정적 팩터리**라면
    - 자신이 반환하는 **객체**의 **스레드 안전성**을 반드시 문서화
  - `Collections.synchronizedMap`이 좋은 예시

### 외부에서 사용할 수 있는 락 제공
- 클래스가 외부에서 사용할 수 있는 **락**을 제공하면
  - C에서 일련의 **메서드 호출**을 **원자적**으로 수행할 수 있음
- 하지만 이 유연성에는 **대가**가 따름
- 내부에서 처리하는 **고성능 동시성 제어 매커니즘**과 혼용할 수 없음
- 그래서 `ConcurrentHashMap`과 같은 **동시성 컬렉션**과는
  - **함께 사용할 수 없음**
- 또한 C가 **공개된 락**을 오래 쥐고, 놓지 않는 **서비스 거부 공격**(denial-of-service attack)을 수행할 수 있음
- 서비스 거부 공격을 방어하려면
  - `synchronized` 메서드(공개된 락과 마찬가지) 대신 **비공개 락 객체**를 사용해야 함

### 비공개 락 객체 관용구
- 코드
  ```java
  private final Object lock = new Object();

  public void foo() {
    synchronized(lock) {
      ...
    }
  }
  ```
- 무조건 **스레드 안전** 클래스에서만 사용할 수 있음
- **조건부 스레드 안전 클래스**에서는
  - 특정 호출 **순서**에 필요한 락이 무엇인지를 C에게 알려줘야 하므로
    - 위 관용구를 사용할 수 없음

### 비공개 락 객체의 특징
- **비공개 락 객체**는 **클래스 밖**에서는 볼 수 없기 때문에
  - C가 그 객체의 **동기화**에 관여할 수 없음
- ITEM.15의 조언을 따라
  - **락 객체**를 **동기화 객체**안으로 **캡슐화** 한 것
- 위 예시코드에서 `lock` 필드를 `final`로 선언
  - 우연히라도, 락 객체가 교체되는 상황을 예방
  - 락이 교체되면 끔찍한 결과로 이어짐(ITEM.78)
  - ITEM.17의 조언을 따라
    - **락 필드의 변경 가능성 최소화**
  - **락 필드**는 항상 `final`로 선언할 것
  - 일반적인 감시락이든 `java.util.concurrent.locks` 패키지는 마찬가지

### 비공개 락 객체 관용구의 활용
- 상속용으로 설계한 클래스(ITEM.19)에서 잘 활용 됨
- **상속용 클래스**에서 자신의 인스턴스를 **락**으로 사용한다면,
  - 하위 클래스는 쉽게, 의도치 않게 **기반 클래스**의 동작을 방해할 수 있음
    - 그 반대 상황도 마찬가지
- 같은 락을 **다른 목적**으로 사용하게 되어
  - 하위 클래스와 기반 클래스가 서로 **간섭**이 일어나게 됨
- 단지 가능성 있는 상황이 아닌,
  - 실제 `Thread` 클래스에서 나타나는 문제

### 핵심 정리
- 모든 클래스가 자신의 **스레드 안전성 정보**를 명확히 **문서화**해야 함
- 정확한 언어로 명확히 설명하거나,
  - **스레드 안전성 애너테이션**을 활용할 수 있음
- `synchronized` 한정자는, 문서화와 관련이 없음
- **조건부 스레드 안전 클래스**는
  - 메서드를 어떤 **순서**로 호출할 때, **외부 동기화**가 요구되고
  - 그때 어떤 **락**을 얻어야하는지도 알려줘야 함
- **무조건적 스레드 안전 클래스**를 작성할 때는
  - `syncrhonized` 메서드가 아닌 **비공개 락 객체**를 사용해야 함
  - 이렇게 해야 C나 **하위 클래스**에서
    - 동기화 매커니즘을 깨뜨리는걸 **예방**할 수 있음
    - 또한 다음에 더 정교한 동시성을 제어 매커니즘으로 재구현할 여지가 생김