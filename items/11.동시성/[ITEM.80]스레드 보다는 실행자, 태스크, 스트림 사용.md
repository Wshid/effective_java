## [ITEM.80] 스레드 보다는 실행자, 태스크, 스트림 사용

### work queue
- 이 책 초판의 **ITEM.49**에서는 작업 큐를 사용함
- 해당 클래스는 C가 요청한 작업을 **백그라운드 스레드**에 위임하여
  - **비동기적**으로 처리
- 작업 큐가 필요 없어지면
  - C는 큐에 중단을 요청할 수 있으며,
  - 큐는 남아 있는 작업을 마저 완료한 후, 스스로 종료 됨
- 예시용의 간단한 코드였으나, 책 한페이지의 분량
  - **안전 실패**나 **응답 불량**을 대응하기 위해, 코드를 추가해야했기 때문
  - 다행히도, 현재는 이런 코드를 사용하지 않아도 됨

### java.util.concurrent
- 이 책의 2판이 나오기 전에 해당 패키지가 등장함
- 이 패키지는 **실행자 프레임워크**(Executor Framework)라고 하는
  - **인터페이스 기반**의 유연한 **태스크 실행 기능**을 담고 있음
- 초판의 코드보다 모든 면에서 뛰어는 작업 큐를 다음과 같이 생성
  ```java
  ExecutorService exec = Executors.newSingleThreadExecutor();

  // 실행자에 실행할 태스크(task, 작업)을 넘기는 방법
  exec.execute(runnable); 

  // 실행자를 우아하게 종료시키는 방법(해당 작업이 실패하면 VM 자체가 종료되지 않음)
  exec.shutdown();
  ```
  - 이외에도 실행자 서비스의 기능은 많음

### 실행자 서비스의 기능
- `get`
  - 특정 태스크가 완료되기를 기다림
  - ITEM.79의 `get` method
- `invokeAny` / `invokeAll`
  - 태스크 모음 중 아무것 하나,
  - 혹은 모든 태스크(`invokeAll` 메서드)가 완료되기를 기다림
- `awaitTermintaion`
  - 실행자 서비스가 종료하기를 기다림
- `ExecutorCompletionService`
  - 완료된 태스크들의 결과를 차례로 받음
- `ScheduledThreadPoolExecutor`
  - 태스크를 특정 시간에 혹은 주기적으로 실행

### 큐를 둘 이상의 스레드가 처리하게 하는 방법
- 큐를 **둘 이상의 스레드**가 처리하게 하고 싶으면
  - 간단히 다른 **정적 팩터리**를 이용하여
  - 다른 종류의 실행자 서비스(**스레드 풀**)을 생성하면 됨
- 스레드 풀의 **스레드 개수**는
  - 고정할 수도 있고, 필요에 따라 늘어나거나, 줄어들게 설정 가능
- 필요한 생성자 대부분은
  - `java.util.concurrent.Executors`의 **정적 팩터리**를 이용하여 생성 가능
- 평범하지 않은 실행자를 원한다면
  - `ThreadPoolExecutor` 클래스를 직접 사용해도 됨
- 이 클래스로는 **스레드 풀 동작**을 결정하는
  - 거의 모든 속성을 설정할 수 있음

### 실행자 서비스를 사용하기에 까다로운 어플리케이션
- 실행자 서비스를 사용하기에 까다로울 경우 사용 방법
- 작은 프로그램이나 가벼운 서버라면
  - `Executors.newCachedThreadPool`이 좋은 선택
    - 특별히 설정할 게 없으며, **일반적인 용도로 적합하게 동작**
- `CachedThreadPool`은 무거운 프로덕션 서버에는 좋지 못함
  - 요청받은 태스크들이 큐에 쌓이지 않고
    - 즉시 **스레드에 위임**되어 실행
  - 가용한 스레드가 없다면 **새로 하나를 생성**
  - 서버가 아주 무겁다면, cpu가 100% 사용률을 보일 수 있으며,
    - 새로운 태스크가 도착하는 순간,
      - 계속 새로운 스레드를 생성하면서, 상황이 **악화될 수 있음**
- 무거운 프로덕션 서버에서는
  - 스레드 개수를 **고정**한 `Executors.newFixedThreadPool`을 선택하거나
  - 완전히 통제할 수 있는 `ThreadPoolExecutor`를 사용하는 것이 좋음

### 실행자 프레임워크를 사용해야하는 이유
- **작업 큐**를 직접 만드는 일은 좋지 못하며,
  - **스레드**를 직접 다루는 것도 좋지 못함
- 스레드를 직접 다루게 될경우,
  - `Thread`가 **작업 단위**와 **실행 매커니즘**의 역할을 모두 수행하게 됨
- 반면 **실행자 프레임워크**에서는
  - 작업 단위와 실행 매커니즘이 **분리**
- **작업 단위**를 나타내는 핵심 추상 개념이 **태스크**
- **태스크**의 종류(2)
  - `Runnable`, `Callable`
    - `Callable`은 `Runnable`과 비슷하지만,
      - 값을 반환하고, 임의의 예외 반환이 가능
- 태스크를 수행하는 일반적인 매커니즘 = **실행자 서비스**
- 태스크 수행을 **실행자 서비스**에 맡기면
  - 원하는 태스크 수행 **정책**을 선택할 수 있고,
  - 생각이 바뀌면 변경이 가능함
- 핵심은
  - **컬렉션 프레임워크**가 데이터 모음을 담당하듯,
  - 실행자 프레임워크가 **작업 수행**을 담당함

### ForkJoinTask
- `java 7`이 되면서, **실행자 프레임워크**는
  - fork-join 태스크를 지원하도록 확장 됨
- **ForkJoinTask**는
  - `ForkJoinPool`이라는 **특별한 실행자 서비스**가 실행해줌
- `ForkJoinTask`의 인스턴스는
  - 작은 하위 태스크로 나뉠 수 있음
- `ForkJoinPool`을 구성하는 스레드들이 이 태스크들을 처리하며,
  - 일을 먼저 끝낸 **스레드**는
  - 다른 스레드의 남은 태스크를 가져와 **대리 처리**가 가능함
- 이렇게 하여, 모든 스레드가 바쁘게 움직여
  - `cpu`를 최대한 활용하면서, **높은 처리량**과 **낮은 지연 시간** 달성
- 이러한 `ForkJoinTask`를 직접 작성하고 튜닝하기엔 어렵지만,
  - `ForkJoinPool`을 이요해 만든 병렬 스트림(ITEM.48)을 이용하면
  - 적은 노력으로 이점 누리기 가능
- 물론 `ForkJoin`에 적합한 작업이어야 함

### 추가
- 실행자 프레임워크의 기능은 이 외에도 많음
- 자바 병렬 프로그래밍(acon, 2008) [Goetz06]에 추가적인 내용이 있음