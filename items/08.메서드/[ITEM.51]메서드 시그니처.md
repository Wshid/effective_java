## [ITEM.51] 메서드 시그니처
- API 설계 요령
- 해당 요령을 지킬경우
  - 배우기 쉽고, 쓰기 쉬우며, 오류 가능성이 적은 API 설계 가능

### 메서드 이름을 신중하게 짓기
- **표준 명명규칙(ITEM.68)**
- 같은 **패키지**에 속한 다른 이름들과 일관되게 짓는게 최우선
- 개발자 커뮤니티에서 널리 받아들여지는 이름 권고
- 긴 이름은 피하기
- 애매할 경우, **자바 라이브러리의 API 가이드** 참고
  - 일관되지 않은 이름도 많으나, 대부분 납득할만한 수준

### 편의 메서드를 너무 많이 만들지 말기
- 모든 메서드는 각각 자신의 역할만
- **메서드가 너무 많은 클래스**는
  - 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 **어려움**
- **인터페이스**도 동일함
  - 메서드가 많을경우 불편함
- **클래스**나 **인터페이스**는
  - 자신의 각 기능을 완벽히 수행하는 **메서드**로 제공하여야 함
- 아주 자주 쓰일 경우에만 **별도의 약칭 메서드** 권고
- 확신이 서지 않으면 만들지 말 것

### 매개변수 목록은 짧게 유지하기
- **4개 이하** 권고
- 4개가 넘어갈 경우, **매개변수**를 전부 기억하기 어려움
- **같은 타입**의 **매개변수** 여러개가 연달아 나오는 경우 더 혼잡함
  - 매개변수 순서를 기억하기 어려움
  - 실수로 순서를 변경했을때,
    - 그대로 **컴파일 되어 실행**

### 과하게 긴 매개변수를 짧게 줄여주는 기술 - 메서드 분할
- 여러 메서드로 쪼개기
- 쪼개진 메서드 각각은 **원래 매개변수 목록**의 **부분집합**을 받는다.
- 잘못하면 메서드가 너무 많아질 수 있으나,
  - **직교성(orthogonality)**이 높아져, 메서드를 줄여주는 효과 존재
- `java.util.List` 인터페이스가 좋은 예시
  - 리스트에서 주어진 **원소의 인덱스**를 찾는데, 지정된 범위의 **부분 리스트**에서 인덱스를 찾는 경우
    - 하나의 메서드로 구현하려면
      - 부분리스트의 **시작**, **끝**, **찾을 원소**, 3가지가 필요
    - 실제 `List`에서는 다음을 별개로 제공
      - 부분리스트를 반환하는 `subList` 메서드
      - 주어진 원소의 인덱스를 알려주는 `indexOf` 메서드
    - `subList`가 반환한 부분리스트 역시 `List`이기 때문에
      - 두 메서드를 조합하면, 원하는 목적 부합 가능

### orthogonal의 의미
- 직교
- 수학적인 의미
  - 서로 직각을 이루며 교차한다는 수학적인 뜻
  - 직교하는 요소는 서로 **독립적**이다
  - 직교하는 두 벡터의 **내적 = 0**
    - 두 벡터에는 **서로 영향을 주는 성분이 전혀 없음**을 의미
- 소프트웨어에서의 의미
  - 직교성이 높다 = **공통점이 없는 기능들이 잘 분리되어 있다**
  - **기능**을 **원자적으로 쪼개 제공한다**의 의미
- 위의 `List`예시의 경우
  - `subList`와 `indexOf`의 역할이 서로 관련이 없음
  - 두 기능을 **개별 메서드**로 제공해야, **직교성**이 높음

### 직교성을 높여, 메서드 수를 줄여주는 효과
- 메서드가 쪼개졌는데, 오히려 수가 줄어드는 경우?
- 기능을 원자적으로 쪼개다 보면
  - 자연스럽게 **중복**이 줄고, **결합성**이 낮아짐
  - 코드를 수정하기에 수월하다
  - 테스트 하기도 쉬움
- 직교성이 높을 경우
  - 가볍고, 구현하기 쉽고, 유연하고 강력

### 무작정 작게 나누는 것이 좋은가
- API 사용자가 다루는 개념의 **추상화 수준**에 맞게 조절
- **특정 조합**의 패턴이 상당히 자주 사용되거나,
  - 최적화하여 성능이 크게 개선된다면
  - **직교성**이 낮아지더라도, **편의 기능**으로 제공하는 편이 좋음
- **직교성**은 절대 가치가 아닌
  - **철학**과 **원칙**을 가지고 **일관되게 적용**

### 직교성 개념의 확대
- 소프트웨어 전 설계 분야로 확대
- 저수준의 경우 **RISC**, **CISC**가 대표적
  - RISC : 직교성이 높음
  - CISC : 직교성이 낮음
- 고수준의 경우, **클래스**, **패키지**, **모듈 설계**에서 적용
- 아키텍쳐 관점
  - microservice architecture : 직교성이 높음
  - monolithic architecture : 직교성이 낮음

### 과하게 긴 매개변수를 짧게 줄여주는 기술 - 도우미 클래스 제작
- **정적 멤버 클래스(ITEM.24)**로 주로 사용
- 특히 잇따른 **매개변수** 몇 개를 **독립된 하나으 개념**으로 볼 때 추천하는 기법
- 카드게임 클래스 예시
  - 메서드 호출시, 카드의 숫자(rank)와 무늬(suit)를 뜻하는 두 매개변수 전달
  - 매개변수를 항상 **같은 순서**로 전달
  - 이 둘을 묶는 **도우미 클래스**를 만들어
    - **하나의 매개변수**로 주고 받으면
    - API 및 클래스 내부 구현도 깔끔해짐

### 과하게 긴 매개변수를 짧게 줄여주는 기술 - 메서드 분할 & 도우미 클래스
- 객체 생성한 **빌더 패턴(ITEM.2)**를 **메서드 호출**에 응용
- 매개변수가 **많을 때**, 특히 일부는 **생략해도 괜찮을 때** 도움이 됨
- 모든 매개변수를 하나로 **추상화한 객체**를 정의
  - C에서 이 객체의 `setter method`를 호출하여 값을 설정
- 각 `setter method`의 경우
  - 매개변수 **하나**혹은 연관된 **몇 개만** 설정함
- C는 먼저 **필요한 매개변수 설정** 이후
  - `execute` 메서드를 호출하여, **매개변수 유효성 검사**
- 마지막으로, 설정이 **완료**된 객체를 넘겨 계산 수행

### 매개변수의 타입은 인터페이스
- 매개변수 타입 지정시, **클래스** 보다 **인터페이스**가 좋음(ITEM.64)
- 매개변수로 적합한 **인터페이스**가 있다면(이를 구현한 **클래스**가 아닌)
  - 그 인터페이스를 **직접 사용 할 것**
- 예를 들어
  - 메서드에 `HashMap`을 넘길일은 없으며, `Map`을 사용
  - `HashMap` 뿐만 아니라
    - `TreeMap`, `ConcurrentHashMap`, `TreeMap`의 부분맵 등
    - 어떠한 `Map`구현체도 인수로 사용 가능
  - 아직 존재하지 않는 `Map`도 사용 가능함
- **인터페이스** 대신 **클래스**를 사용하면
  - C에게 **특정 구현체**만 사용하도록 제한하는 꼴
  - 혹시라도 **입력 데이터**가 다른 형태로 존재할 때
  - 명시된 **특정 구현체**의 객체로 **비싼 복사 비용**을 감당해야 함

### `boolean`보다는 원소 2개의 열거 타입 사용
- 단, 메서드 이름상 `boolean`을 받아야 의미가 명확할 때는 제외
- **열거 타입**을 사용하면, 코드를 읽고/쓰기 쉬움
- 온도 예시
  - 화씨와, 섭씨 표현
  ```java
  public enum TemperatureScale {
    FAHRENHEIT,
    CELSIUS
  }
  ```
  - 온도계 클래스의 **정적 팩터리 메서드**가
    - 이 열거타입을 받아 적합한 온도계 **인스턴스**를 생성한다면,
    ```java
    Thermometer.newInstance(true);
    Thermometer.newInstance(TemperatureScale.CELSIUS); // 명확한 표기
    ```
  - 추후 온도계 클래스에 켈빈 온도등을 지원해야 할때
    - 별도의 **정적 메서드** 필요 없이, **열거 타입**에 추가하면 됨
  - 온도 단위에 대한 **의존성**을,
    - **개별 열거 타입 상수의 메서드** 안으로 리팩터링 가능(ITEM.34)
    - `double` 값을 받아, **CELISIUS**로 변환해주는 메서드를
      - 상수 각각에 정의 가능
