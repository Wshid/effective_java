## [ITEM.49] 매개변수 유효검사
### 메서드
- 메서드를 설계할 때 주의할 점
  - 매개변수와 반환값의 처리
  - 메서드 시그니처의 설계
  - 문서화 방법
- **메서드** 뿐 아니라 **생성자** 내용 포함
- **사용성, 견고성, 유연성**에 초점

### 조건 만족의 필요성
- **매서드**와 **생성자** 대부분은
  - **입력 매개변수** 값이 특정 조건을 만족
- 사례
  - `not {index} < 0`
  - `객체 참조 != null`
- 조건들은 반드시 **문서화** 해야 하며,
  - 메서드 **몸체**가 시작되기 전에 검사해야 함
- **오류는 ASAP 빨리(발생한 곳에서) 잡아야 함**
  - 즉시 잡지 않을경우,
    - 오류 감지가 어렵고, 오류의 발생 지점을 찾기 어려워짐

### 메서드 몸체 실행전 매개변수 확인
- 메서드 몸체 실행전에, **매개변수를 확인**하면
  - 잘못된 값이 넘어왔을때
  - 즉각적이고 깔끔하게 **예외** 발생 가능

### 매개변수 검사를 제대로 하지 못할 경우 발생하는 문제
- 메서드가 **수행되는 중간**에 **모호한 예외**를 던지며 실패할 수 있음
- 메서드가 수행되나, **잘못된 결과** 반환
- 메서드는 문제없이 수행되었으나
  - 타 객체의 상태 변환으로, **미래**의 알수 없는 시점에
  - 메서드와 관련 없는 오류 발생
- 매개변수 검사에 실패하면
  - **실패 원자성**(failure atomicity, ITEM.76)을 어기는 결과

### public과 protected 메서드의 문서화
- `public`과 `protected` 메서드는
  - **매개변수 값**이 잘못되었을 때, 던지는 예외를 문서화 해야 함
- `@throws`를 활용(ITEM.74)
- 보통은
  - `IllegalArgumentException`
  - `IndexOutOfBoundsException`
  - `NullPointerException`
  - 을 발생(ITEM.72)
- 매개변수 제약을 **문서화**한다면,
  - 그 제약을 어겼을때 **발생하는 예외**를 함께 기술
- API 사용자가 제약을 지킬 가능성을 높일 수 있음
- 예시
  ```java
  /**
    * 항상 음이 아닌 BigInteger를 반환한다는 점에서, remainder 메서드와 다름
    * @param  m 계수(양수여야 함)
    * @return 현재 값 mod m
    * @throws ArithmeticException m이 0보다 작거나 같으면 발생
    * */
  public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0) 
      throw new ArithmeticException("m은 양수여야 함 " + m);
    // ... 계산 수행
  }
  ```
  - `m == null` 이면
    - `m.signum()` 호출 시, `NullPointerException` 발생
  - 하지만, `m이 null일 때 NullPointerException을 던진다`라는 말이 기술되어 있지 않음
    - 이 설명을 **개별 메서드**가 아닌 `BigInteger` 클래스 수준에서 기술했기 때문
- **클래스 수준 주석**은
  - 그 클래스의 모든 `public` 메서드에 적용되므로,
  - 각 메서드에 일일히 기입하는 것보다 훨씬 깔끔한 방법
- `@Nullable`이나, 비슷한 **애너테이션** 사용하여
  - 특정 매개변수가 `null`이 될 수 있다고 알려줄수는 있으나,
  - **표준적인 방법은 아님**
- 또한 같은 목적으로 사용할 수 있는 **애너테이션**이 여러 종류

### requireNonNull
- `java 7`에 추가
- `java.util.Objects.requireNonNull` 메서드
- 유연하고 사용하기 편함
- `null` 검사를 수동으로 하지 않아도 됨
- 원하는 **예외 메세지** 지정 가능
- **입력**을 그대로 반환하기 때문에,
  - 값을 사용하는 **동시에** `null` 검사 수행 가능
- 예시
  ```java
  this.strategy = Objects.requireNonNull(strategy, "전략");
  ```
- **반환값**은 그냥 **무시**하고, 필요한 곳 어디서든
  - 순수한 `null`검사 목적으로 사용해도 된다.

### Objects 범위 검사 기능
- `java 9`에 추가
- `checkFromIndexSize`, `checkFromToIndex`, `checkIndex` 메서드
- 제약 사항
  - `null`검사 메서드만큼 유연하지는 않음
  - **예외 메세지**를 지정할 수 없음
  - **리스트**와 **배열** 전용으로 설계
  - `closed range`(닫힌 범위, 양 끝단 포함)을 다루지 못함
- 위의 제약에 걸리지 않으면, 유용하고 편리함

### 공개되지 않은 메서드의 검사
- **공개되지 않은 메서드**라면
  - 메서드가 호출되는 상황 통제 가능
- **유효한 값**만이 **메서드**에 넘겨질 것을
  - **보증** 해야 함
- `public`이 아닌 메서드라면
  - `assert`(단언문)을 사용해 **매개변수 유효성** 검증 가능
- 예시
  ```java
  private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >=0 && offset <= a.length;
    assert length >=0 && length <= a.length - offset;
    // ... 계산 수행
  }
  ```
  - **단언문**은 자신이 단언한 조건이 **무조건 참** 이라고 선언 함
    - 이 메서드가 포함된 **패키지**를 C가 어떤식으로 다루어도 상관 없음

### 단언문과 유효성 검사의 차이
- 실패하면 `AssertionError`를 발생
- `Runtime`에 아무런 효과 및 성능저하가 없음
  - 단, java 실행시 명령줄에서
    - `-ea` 혹은, `--enableassertions` 플래그 설정시
    - `Runtime`에 영향 발생

### 추후 사용을 위한 매개변수 유효성 검사
- **매서드**가 직접 사용하지는 않으나,
  - 나중에 쓰기 위해 **저장하는 매개변수**의 검사는 철저해야 함
- 예시
  ```java
  static List<Integer> intArrayAsList(int[] a) {
    Objects.requireNonNull(a);
    ...
  }
  ```
  - 입력받은 `int`배열의 `List` 뷰(view)를 반환하는 메서드
  - 해당 메서드는 `Objects.requireNonNull`을 이용하여 `null` 검사 수행
    - C가 `null`을 건네면 `NullPointerException` 발생
  - 해당 검사를 생략했다면
    - 새로 생성한 `List` 인스턴스 반환
    - C가 돌려받은 `List`를 사용할 때야, `NullPointerException`이 발생
      - `List`를 어디서 가져왔는지 추적하기 어려움 => **디버깅**이 어려워짐

### 생성자, 추후 사용을 위한 매개변수 유효성 검사의 예외
- **생성자 매개변수**의 **유효성 검사**는
  - **클래스 불변식**을 어기는 객체가 만들어지지 않게 하는데 꼭 필요

### 메서드 몸체 실행전 매개변수 유효성 검사의 예외
- **유효성 검사 비용**이 지나치게 높거나, 실용적이지 않을때
- 계산과정에서 **암묵적으로** 검사가 수행될 때
- 사례
  - `Collections.sort(List)`, 객체 리스트를 정렬하는 메서드
  - 리스트 안의 객체는 모두 **상호 비교**되어야 하며
    - **정렬** 과정에서 비교가 이루어 진다.
  - 비교할 수 없는 **타입**의 객체가 들어있다면
    - 객체 비교시에, `ClassCastException`이 발생함
  - 따라서 **비교하기 전에**
    - 리스트 안의 모든 객체가 상호 비교가능한지 검사해도 큰 이익이 없음
  - 하지만, **암묵적 유효성 검사**에 너무 의존하면
    - **실패 원자성**(ITEM.76)을 해칠 수 있음

### 계산 과정에서의 유효성 검사
- 계산 과정에서 **유효성 검사**가 이뤄지지만
  - 실패했을 때 **잘못된 예외**를 던지기도 함
- `잘못된 매개변수 값을 사용해 발생한 예외 != API 문서에서 던지기로 한 예외`
- 이런 경우, **예외 번역**(exception traslate, ITEM.73)을 사용하여
  - **API 문서**에 기재된 예외로 변경해주어야 함

### 주의
- **매개변수**에 제약을 두는게 좋다는 것이 아님
- 사실은 그 반대
- **메서드는 최대한 범용적으로 설계해야 함**
- 메서드가 건네받는 값으로, 무언가 제대로 된 할 일을 할 수 있다면,
  - **매개변수 제약**은 **적을수록** 좋음
- 하지만 구현하려는 **개념** 자체가 **특정한 제약**을 내재한 경우도 많음

### 결론
- **매서드**나 **생성자**를 작성할 때면,
  - **매개변수**들에 어떠한 **제약**이 있을지 생각해야 한다
- 그 제약들을 **문서화**하고
  - 메서드 코드 시작부분에 **명시적으로 검사**해야 함
- **유효성 검사**가 **실제 오류**를 처음 걸러낼 때 효과적