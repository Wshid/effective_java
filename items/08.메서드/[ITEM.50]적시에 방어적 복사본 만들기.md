## [ITEM.50] 적시에 방어적 복사본 만들기
### 자바의 안전함
- 네이티브 메서드를 사용하지 않음
- C나 C++와 다르게 다음과 같은 **메모리 충돌 오류**에서 안전
  - 버퍼 오버런
  - 배열 오버런
  - 와일드 포인터
- 자바가 작성한 **클래스**는
  - 시스템의 다른 부분에서 무슨 짓을 하든
  - **불변식**이 지켜짐
- 메모리 전체를 하나의 거대한 배열로 다루는 언어에서는 누릴 수 없는 가엄

### 다른 클래스의 침범
- 자바라도, 다른 클래스의 침범을 아무 노력 없이 막을 수 없음
- C가 불변식을 깨뜨릴 수 있다 가정하고,
  - **방어적**으로 프로그래밍 해야 함
- 어떤 객체든 해당 객체의 허락 없이는 **내부의 수정**은 불가하나,
  - 주의를 하지 않으면 가능할 수 있게 됨

### 예시 - 불변식을 지키지 못한
- `period`를 표현하는 클래스
- 한번 값이 정해지면 변하지 않도록 설계
- 코드
  ```java
  public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
      if (start.compareTo(end) > 0)
        throw new IllegalArgumentException(start + "가" end + "보다 늦음");
      this.start = start;
      this.end = end;
    }

    public Date start() {
      return start;
    }

    public Date end() {
      return end;
    }
    ...
  }
  ```
- 클래스가 **불변**처럼 보이며,
  - `시작 시간 < 종료 시각`의 불변식이 잘 지켜질 것 같다
- 하지만 `Date`가 가변
  - 불변식은 쉽게 깨어질 수 있음
- `Period` 인스턴스 내부 공격 코드
  ```java
  Date start = new Date();
  Date end = new Date();
  Period p = new Period(start, end);
  end.startYear(78); // p의 내부 직접 수정
  ```

### java 8 이후의 해결 방법
- 쉽게 해결 가능
- `Date` 대신, 불변(ITEM.17)인 `Instant`를 사용하면 됨
  - 또는 `LocalDateTime`이나 `ZonedDateTime`을 사용
- `Date`는 오래된 API이므로,
  - 새로운 코드를 작성할 때는 더 이상 사용하면 안됨
- `Date`처럼 가변인 낡은 값 타입을 사용하는 API가 많기 때문에
  - 해당 낡은 코드들을 대체 해주어야 함

### 외부 공격으로부터 인스턴스 내부 보호 방법 - defensive copy
- **생성자**에서 받은 **매개변수** 각각을 **방어적으로 복사(defensive copy)**
- 개선된 코드
  ```java
  public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());

    if (this.start.compareTo(this.end) > 0)
      throw new IllegalArgumentException(
        this.start + "가 " + this.end + "보다 늦음"
      );
  }
  ```
  - `Period` 인스턴스에서, 원본이 아닌 **복사본**을 사용
- 공격은 더 이상 `Period`에 위협이 되지 않음

### 유효성 검사 전 방어적 복사
- **매개변수의 유효성 검사**(ITEM.49)하기 전에
  - **방어적 복사본**을 만들고,
  - 이 **복사본**으로 유효성 검사
- 순서가 부자연스러워 보이나, 이를 추천함
- 유효성 검사 이후, 복사본을 만드는 시점에
  - **다른 스레드**가 **원본 객체**를 수정할 수 있음
- **방어적 복사**를 **유효성 검사**이전에 수행
- 위와 같은 시점 공격을
  - **검사시점/사용시점 공격(time-of-check/time-of-use)**
  - **TOCTOU** 공격

### Date::clone 메서드를 사용하지 않음
- 방어적 복사에, `Date::clone`을 사용하지 않는다
- `Date`는 `final`이 아니기 때문에
  - `clone`이 `Date`를 정의한게 아닐 수 있음
  - `clone`이 악의를 가진 하위 클래스의 인스턴스를 반환할 수 있음
- 하위 클래스는 `start`와 `end` 필드의 참조를
  - `private` 정적리스트에 담아 두었다가
  - 공격자에 해당 리스트 접근 가능하도록 할 수 있음
- 이 공격을 막기 위해서는
  - **매개변수**가 제 3자에 의해 **확장될 수 있는 타입**이라면,
  - 방어적 복사본을 만들때, `clone`을 사용하면 X

### 또 다른 공격
- `Period` 인스턴스의 변경 가능
- **접근자 메서드**가 내부 **가변 정보**를 직접 드러내기 때문
- 공격 코드
  ```java
  Date start = new Date();
  Date end = new Date();
  Period p = new Period(start, end);
  p.end().setYear(78); // p의 내부 변경
  ```
- 단순 **가변 필드**의 **방어적 복사본** 반환으로 해결
  ```java
  public Date start() {
    return new Date(start.getTime());
  }

  public Date end() {
    return new Date(end.getTime());
  }
  ```
- `Period`가 불변이 됨
- `Period` 자신 외에, 가변 필드에 접근할 방법이 없음
- 단, **네이티브 메서드**나 **reflection** 같이
  - 언어 외적인 수단을 사용하면 가능

### 접근자 메서드의 clone
- 생성자와 달리, **접근자 메서드**에는
  - 방어적 복사에 `clone`을 사용해도 됨
- `Period`가 가지고 있는 `Date` 객체는
  - `java.util.Date` 임이 확실하기 때문
  - 신뢰 할 수 없는 하위 클래스가 아님
- 그래도 ITEM.13 처럼
  - **인스턴스 복사**시에는, **생성자**나 **정적 팩터리**를 사용하는 것이 좋음

### 객체의 변경 고려
- **매개변수**를 방어적으로 복사하는 목적이 **불변 객체**를 만들기 위해서만은 아님
- **메서드**든 **생성자**든
  - C가 제공한 **객체 참조**를 **내부 자료구조**에 보관시,
  - 그 객체가 잠재적으로 변경 가능한지 확인해야 함
- **변경 가능 객체**라면
  - 그 객체가 **클래스**에 넘겨진 뒤
  - 임의로 변경 되어도, 클래스에 문제가 없을지 파악해야함
- 확신할 수 없다면,
  - **복사본**을 만들어 저장해야 함
- 예시
  - C가 건네준 객체를 내부 `Set` 인스턴스에 저장하거나,
  - `Map` 인스턴스의 **키**로 사용한다면
    - 추후 그 객체가 변경될 때, `Set/Map`의 **불변식은 깨짐**

### 내부 객체 C 전달시 방어적 복사
- 클래스가 불변이든 가변이든, C에 반환시
  - **방어적 복사**하여 반환해야 함
- **원본**을 노출하지 말고, **방어적 복사본**을 반환할 것
- 또는 **배열의 불변 뷰**를 반환
  - ITEM.15 참고

### 되도록 불변 객체 사용
- 되도록 불변 객체를 조합하여, 객체를 구성하기
  - 그래야 **방어적 복사**를 할일이 줄어든다.
- `Period` 예시의 경우
- `java 8`이상일 경우
  - `Date` -> `Instant|LocalDateTime|ZonedDateTime`
- `java 8`이전일 경우
  - `Date`의 참조 대신
  - `Date.getTime()`이 반환하는 `long` 정수 사용

### 방어적 복사의 단점
- 성능 저하
- 항상 사용 가능한 것이 아님
- 같은 패키지에 속하는 등의 이유로
  - **호출자**가 컴포넌트 내부를 수정하지 않는다 확신한다면
  - 방어적 복사를 **생략**해도 된다.
- 이러한 상황이어도,
  - 호출자에게 해당 **매개변수**나 **빤환값**을 수정하지 말아야함을
  - **문서화**하는 것이 중요 

### 무조건 방어적 복사?
- 다른 패키지에서 사용한다고 해서
  - **가변 매개변수**를 항상 **방어적 복사**로 저장해야 하는 것은 아님
- 때로는 **메서드**나 **생성자**의 **매개변수**로 넘기는 행위가
  - 그 객체의 **통제권**을 명백히 이관한다는 의미
- 통제권을 이전하는 **메서드**를 호출하는 C는
  - 더 이상 객체를 **직접 수정**하는 일이 없다고 약속해야 함
- C가 건네주는 **가변 객체**의
  - 통제권을 넘겨받는다고 기대하는 **메서드**나 **생성자**에서도
  - 그 사실을 **문서화** 해야함

### 통제권의 전달과 취약점
- **통제권**을 넘겨받기로 한
  - **메서드**나 **생성자**를 가진 클래스들은
  - 악의적인 C의 공격에 취약
- 따라서 **방어적 복사**를 **생략**해도 되는 상황은
  - 해당 **클래스**와 C가 상호 신뢰 가능할 때,
  - 혹은 **불변식**이 꺠지더라도
    - 그 영향이 C에만 국한될 때로 **한정**해야 함
    - **Wrapper Class**(ITEM.18)
      - 래퍼 클래스 특성상
        - C는 **래퍼에 넘긴 객체**에 여전히 접근 가능
      - **래퍼의 불변식 파괴**는 쉽게 가능하나
        - C에만 영향 받음

### 정리
- 클래스가
  - C와 관련되며(C로 부터 받거나, 반환하는)
  - 구성요소가 **가변**이라면,
    - 그 요소는 반드시 **방어적 복사** 해야 함
- **복사 비용**이 너무 크거나,
  - C가 그 요소를 잘못 수정할 일이 없음을 믿는다면
  - **방어적 복사**를 수행하는 대신,
    - **해당 구성요소**를 수정했을 때의 책임이
    - C에 있음을 **문서화**