## [ITEM.43] 람다 보다는 메서드 참조

### 메서드 참조(method reference)
- 람다의 장점 : 간결함
- 함수 객체를 람다보다 간결하게 만드는 방법
  - 메서드 참조

### 람다 예시 코드
- 임의의 **키**와 `Integer` 값의 매핑을 관리하는 프로그램
- **값**이 **키**의 **인스턴스 개수**로 해석된다면
  - 이 프로그램은 `multiset`을 구현한 형태
- **키**가 맵 안에 없다면 **키:1** 매핑
  - 이미 존재한다면, 매핑 값을 증가시킴
- 코드
  ```java
  map.merge(key, 1, (count, incr) -> count + incr);
  ```
  - `java 8`, `Map`에 추가된 `merge` 메서드 사용
- `merge` 메서드
  - 키, 값, 함수를 인자로 받음
  - 주어진 키가 맵 안에 없다면,
    - `key:value`를 그대로 저장
  - 키가 이미 존재한다면,
    - 세번째 인자로 받은 **함수**를
    - **현재 값**과 **주어진 값**에 적용 이후
      - 현재 값을 덮어쓰는 형태
    - 맵에 `key:value` 형태 저장

### 예시 코드의 단점 - 메서드 참조를 사용한 개선
- 매개변수인 `count`, `incr`은 공간을 꽤 차지 함
- 람다는 단순히 두 인수의 합을 반환
- `java 8`이 되면서 `Integer`와 같은 **박싱 타입**에
  - 람다와 기능이 같은 정적 메서드 `sum`을 지원
- 람다 대신, 이 특징을 활용하면 다음과 같이 변경 가능
  ```java
  map.merge(key, 1, Integer::sum);
  ```
- 매개변수 수가 늘어날 수록, **메서드 참조로 제거할 수 있는 코드양도 증가**
- 하지만 위 에시에서 읽기 쉽고, 유지보수가 쉽게 하려면
  - 람다를 쓰는게 맞음

### 메서드 참조 사용처
- 람다로 할 수 없으면, 메서드 참조로도 개선 불가
- **메서드 참조**를 사용하는 편이 보통 더 간결
  - 람다로 구현했을 때 너무 길거나 복잡하다면 **메서드 참조 사용**
- **람다**로 작성할 코드를 **새로운 메서드**에 담은 다음
  - 람다 다음 그 **메서드 참조**를 사용하는 방법
- IDE는 보통 람다를 **메서드 참조**로 개선하길 추천함. 하지만 비효율적
  ```java
  // method reference
  service.execute(GoshThisClassNameIsHumongous::action);

  // lambda
  service.execute( () -> action());
  ```
  - 오히려 람다가 더 짧고 명확함
- `java.util.function` 패키지가 제공하는
  - **제네릭 정적 팩터리 메서드**인 `Function.identity()`를 사용하기 보다,
  - 똑같은 기능의 람다 `(x -> x)`를 직접 사용하는 편이 나음

### 메서드 참조의 유형(5)
- 정적 메서드를 가리키는 메서드 참조 - 1 
- 인스턴스 메서드를 참조하는 유형
  - 수신 객체(receiving object; 참조 대상 인스턴스)를 특정하는 **한정적(bound) 인스턴스 참조** - 2
    - **정적 참조**와 유사
    - 함수 객체가 받는 인수와, 참조되는 메서드가 받은 인수가 같음
  - 수신 객체를 특정하지 않는 **비한정적(unbound) 인스턴스 참조** - 3
    - 함수 **객체를 적용하는 시점에 수신 객체**를 알려줌
    - 매개변수 목록 순서
      - **수신 객체 전달용 매개변수**
      - 참조되는 메서드 선언에 정의된 매개변수들
    - 주로 **스트림 파이프라인**에서의 매핑과 필터 함수에 쓰임(ITEM.45)
- **클래스 생성자를 가리키는 메서드 참조**와 **배열 생성자**를 가리키는 메서드 참조 - 4/5
  - **생성자 참조**는 **팩터리 객체**로 사용됨

### 메서드 참조 정리 표
- 메서드 참조 유형 및 동일 기능 Lambda 표현
  ```java
  // 정적 참조
  Integer::parseInt
  str -> Integer.parseInt(str) 

  // 한정적 인스턴스
  Instant.now()::isAfter
  Instant then = Instant.now();
  t -> then.isAfter(t)

  // 비한정적 인스턴스
  String::toLowerCase
  str -> str.toLowerCase()

  // 클래스 생성자
  TreeMap<K,V>::new
  () -> new TreeMap<K,V>()

  // 배열 생성자
  int[]::new
  len -> new int[len]
  ```

### Generic function type
- **람다로는 불가능**하나, **메서드 참조**로는 가능한 유일한 예
- 함수형 인터페이스의 **추상 메서드**가 제네릭일 수 있듯이,
  - **함수 타입**도 제네릭이 될 수 있다.
- 인터페이스 계층 구조 예시
  ```java
  interface G1 {
    <E extends Exception> Object m() throws E;
  }
  interface G2 {
    <F extends Exception> String m() throws Exception;
  }
  interface G extends G1, G2 {}
  ```
  - 함수형 인터페이스 `G`를 **함수 타입**으로 표현하면 다음과 같음
  ```java
  <F extends Exception> () -> String throws F
  ```
- **함수형 인터페이스**를 위한 **제네릭 함수 타입**은
  - **메서드 참조 표현식**으로 구현 가능
  - **람다식으로는 불가능**
- **제네릭 람다식**이라는 문법이 존재하지 않음

### 결론
- **메서드 참조**는 람다의 간단명료한 대안
- **메서드 참조**쪽이 짧고 명확하다면, 메서드 참조 사용
  - 그렇지 않을때만 **람다** 사용