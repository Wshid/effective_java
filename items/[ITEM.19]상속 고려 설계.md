## [ITEM.19] 상속 고려 설계
- 메서드 재정의 시의 영향성 검토 및 문서화
    - 상속용 클래스는 `재정의할 수 있는 메서드`를
    - 내부적으로 어떻게 이용하는지 문서화 해야 함
- 클래스의 API로 제공된 공개 메서드에서
    - 클래스 자신의 내부 메서드 호출할 수도 있음
- 호출되는 메서드가 재정의 가능한 메서드라면,
    - 호출하는 메서드의 API 설명에 기술해야 함
- 어떤 순서로 호출하는가, 각각의 호출 결과에 대한 영향성 검토 필요
- '재정의 가능'
    - `public`과 `protected` 메서드 중 `final`이 아닌 모든 메서드
- 재정의 가능 메서드를 호출할 수 있는
    - 모든 상황을 문서로 남겨야 함
    - **백그라운드 스레드**나 **정적 초기화**과정에서도 호출 발생 가능 

### API 문서
- 메서드 설명중 `Implementation Requirements`로 시작하는 절
    - 그 메서드의 **내부 동작 방식**을 설명함
- 메서드 주석에 `@implSpec` 태그를 사용시, javadoc이 자동 생성해 줌

### @implSpec
- java 8에 도입, 9부터 사용
- 태그 활성화 시 `-tag "implSpec:a:Implementation Requirements:"`를 명령줄에 입력해야 함

### hook 선별
- 클래스의 내부 동작 과정 중간에 끼어들 수 있는
- `hook`을 선별하여
- `protected` 메서드 형태로 공개해야 할 수 있음

### 상속용 클래스 설계시, protected 메서드 노출 여부 판단
- 딱 해답은 없음
- 예측 후 하위 클래스 만들어 테스트
- `protected` 메서드 하나하나가 내부구현
    - 수가 적어야 함
- 너무 적게 노출하여 상속 이점을 없애는 경우도 줄여야 함

### 상속용 클래스 시험 방법
- 직접 하위 클래스를 만들어보는 것
- 필요한 `proctected` 메서드를 구현하지 않으면
    - 하위 클래스 작성시, 바로 티가 난다
- 하위 클래스를 여러개 만들때까지, 쓰이지 않는 `protected` 멤버는
    - `private`이어야 함
- 검증에는, 하위클래스 `3개`정도가 적당하다고 함
    - 그 중 하나는 제3자가 작성
- **상속용으로 설계한 클래스는 배포전에**
    - **반드시 하위 클래스를 만들어 검증할 것**

### 상속용 클래스의 생성자 제약 조건
- 상속용 클래스의 생성자는
    - 직접적이든 간접적이든
    - **재정의 가능 메서드 호출 금지**
- 프로그램 오작동의 원인
- 상위 클래스의 생성자가, 하위클래스의 생성자보다 우선순위가 높음
    - 먼저 실행됨
    - 하위 클래스에서 재정의한 메서드가, 그 생성자보다 먼저 호출 가능성 존재
    - **상위 클래스 생성자 --> 하위 클래스 메서드 --> 하위 클래스 생성자** 의 flow가 가능해져 문제 발생

### 문제 발생 예시
>```
>public class Super {
>
>    // 생성자가 재정의 가능 메서드 호출 - 문제
>    public Super() {
>        overrideMe();
>    }
>
>    public void overrideMe(){
>        ...
>    }
>}
>```
>```
>public final class Sub extends Super {
>    private final Instant instant;
>
>    Sub() {
>        instant = Instant.now();
>    }
>
>    // 재정의 가능 메서드, 상위 클래스의 생성자 호출
>    @Override public void overrideMe(){
>        System.out.println(instant);
>    }
>
>    public static void main(String[] args){
>        Sub sub = new Sub();
>        sub.overrideMe();
>    }
>}
>```
- `instant`가 초기화 되기 전에 호출하기 때문에, `null` 값이 호출됨
- `final` 변수인 instant의 상태가 두가지가 될 수 있다.
    - 정상이라면 한가지 상태만을 가져야 함
- `overrideMe`에서 `instant` 객체의 메서드 호출 시에,
    - 상위 클래스의 생성자가 overrideMe 호출,
    - `NullPointerException` 발생
- 단, `private`, `final`, `static` 메서드는
    - 재정의가 불가능 하기 때문에
    - 생성자에서 안심하고 호출해도 됨

### Cloneable, Serializable
- `Cloneable`과 `Serializable` 인터페이스는
    - 상속 설계가 더 어려워 짐
- 둘 중 하나라도 구현한 클래스를 상속할 수 있도록 설계하는 것은
    - 일반적으로 좋지 않은 생각
- `clone`, `readObject` 메서드는, **생성자**와 유사한 효과를 낸다.
- 상속용 클래스에서 `Cloneable`과 `Serializable`을 구현할지 정할 시,
    - 제약 역시 **생성자**와 유사하다는 것에 유의
- **`clone`과 `readObject` 모두, 직/간접적으로**
    - **재정의 가능 메서드를 호출해서는 안됨**
- `readObject`의 경우
    - 하위 클래스가 deserialize되기 전에, 재정의한 메서드부터 호출할 수 있음
- `clone`의 경우
    - 하위 클래스가 `clone` 메서드의 복제본의 상태를 수정하기 전에,
    - 재정의한 메서드 호출

### Serialize 제약 조건
- `Seializable`을 구현한 상속용 클래스가
    - `readResolve`나 `writeReplace` 메서드를 가진다면,
    - 이 메서드는 `protected`로 선언해야 함
- `private`로 선언시, 하위 클래스에서 무시 된다.
- 상속을 허용하기 위해, 내부구현을 클래스 API로 공개하는 예 중 하나

### 상속용 설계
- 클래스를 상속용으로 설계시,
    - 엄청난 노력과, 제약이 많음
- 추상 클래스나, 인터페이스의 골격 구현(`ITEM.20`)
    - 상속을 허용하는게 명백히 정당한 상황
- 불변 클래스(`ITEM.17`)
    - 명백히 잘못된 상황

### 구체 클래스의 상속
-`final`로 선언되지 않고, 상속용으로 설계되거나, 문서화 되지도 않음
- 클래스가 변화될때마다 하위 클래스의 오동작 가능성 농후
- **상속용으로 설계하지 않은 클래스는 상속 금지**
- 또다른 방법
    - 모든 생성자를 `private`이나 `package-private`으로 선언
    - `public` 정적 팩터리 메서드를 만들어주기
- 정적 팩터리 방법은
    - 내부에서 다양한 하위클래스를 만들어 쓰는 **유연성** 제공
    - `ITEM.17`
- 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고
    - 이를 문서화 하기
- 재정의 가능 메서드를 호출하는
    - 자기 사용 코드를 완벽히 제거할 것
- 매서드 재정의 시에도 문제가 발생하지 않기 때문

### 클래스 동작 유지하면서, 재정의 가능 메서드 사용하는 코드 제거 방법
- 각각의 재정의 가능 메서드
    - 자신의 본문 코드를 `private` 도우미 메서드로 옮기기
- 해당 도우미 메서드를 호출하도록 수정
- 재정의 가능 메서드를 호출하는 다른 코드들도
    - 모두 도우미 메서드를 직접 호출하도록 수정

### 결론
- 상속용 클래스 설계는 쉬운 일이 아님
- 클래스 내부에서 스스로를 어떻게 사용하는지(**자기사용패턴**)을 모두 문서화
- 문서화한 것은 클래스가 쓰일 때 반드시 지켜져야 함
    - 아닐 경우, 하위 클래스의 오동작 발생 가능성 존재
- 효율 좋은 하위 클래스 제작을 위해
    - 일부 메서드를 `protected`로 제공해야 할 수 있음
- 클래스를 확장해야할 이유가 없다면
    - 상속을 금지하기
- 상속을 금지하려면
    - 클래스의 `final` 선언
    - 생성자 모두를 외부에서 접근 불가능하도록 하기