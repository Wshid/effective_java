## [ITEM.59] 라이브러리를 익히고 사용

### 무작위 정수 만들기 예제의 문제
```java
static Random rnd = new Random();

static int random(int n) {
  return Math.abs(rnd.nextInt()) % n;
}
```
- 문제
  - `n`이 그리 크지 않은 2의 제곱수 얼마 지나지 않아 같은 수열이 반복
  - `n`이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 자주 반환
    - `n`값이 크면 이 현상은 더 두드려진다.

### 두번째 예시
- 신중히 선택한 범위에서 무작위 수를 백만개를 생성한 다음
- 중간 값보다 작은 게 몇 개인지를 출력
  ```java
  public static void main(String[] args) {
    int n = 2 * (Integer.MAX_VALUE / 3);
    int low = 0;
    for ( int = 0; i < 1000000; i++)
      if (random(n) < n/2)
        low++;
    System.out.println(low);
  }
  ```
- `random` 메서드가 이상적으로 동작한다면
  - 약 50만 개가 출력되야 하지만,
  - 실제로 돌려보면 `666,666`에 가까운 값을 얻는다.
- 무작위로 생성된 수 중에서 `2/3` 가량이
  - 중간값보다 낮은쪽으로 쏠린 것이다.

### random 메서드의 세번째 결함
- 지정한 범위 바깥의 수가 종종 튀어나올 수 있다.
- `rnd.nextInt()`가 반환한 값을
  - `Math.abs`를 이용해 **음수**가 아닌 **정수**로 매핑하기 때문
- `nextInt()`가 `Integer.MIN_VALUE`를 반환하면
  - `Math.abs`도 `Integer.MIN_VALUE`를 반환하고,
  - 나머지 연산자 `%`는 **음수**를 반환한다
    - `n`이 **2의 제곱수**가 아닐 때의 시나리오
- 잘못하면
  - 문제를 해결하고 싶어도, 현상을 재현하기가 쉽지 않을 것

### 결함을 해결하는 방법
- **의사난수 생성기**, **정수론**, **2의 보수** 계산 등에 조예가 깊어야 함
- 해결 방법
  - `Random.nextInt(int)`를 사용하면 됨
- `C`가 이 메서드의 자세한 동작 방식을 몰라도 됨
- **표준 라이브러리**를 사용하면 좋음

### `ThreadLocalRandom`의 사용
- `java 7:` `Random`을 사용하지 않는 게 좋음
- `ThreadLocalRandom`으로 대체하면 대부분 잘 작동한다.
  - `Random` 보다 고품질, 속도도 빠름
- **fork-join 풀**이나 **병렬 스트림**에서는 `SplittableRandom`을 사용

### 표준 라이브러리를 이점 - 두 번째 이점
- 핵심 일과 관련 없는 문제를 해결하느라 시간 소비 x

### 표준 라이브러리를 이점 - 세 번째 이점
- 노력하지 않아도 성능이 지속해서 개선
- 표준 라이브러리 제작자는 더 나은 방법 꾸준히 모색할 수 밖에 없음
- JPL는 많은 부분이 수년에 걸쳐 지속 개선

### 표준 라이브러리 이점 - 네 번째 이점
- 기능이 점점 많아진다는 것
- 라이브러리에 부족한 부분이 있다면
  - 개발자 커뮤니티에서 이야기가 나오고 논의됨
- 다음 릴리스에 해당 기능이 추가되곤 함

### 표준 라이브러리 이점 - 마지막 이점
- 여러분이 작성한 코드가 많은 사람에게 익숙한 코드가 됨
- 다른 개발자들이 더 읽기 좋고,
  - 유지보수하기 좋고
  - 활용하기 쉬운 코드가 됨

### 메이저 릴리스
- 라이브러리에 그런 기능이 있는지 모르기 때문
- **메이저 릴리스마다 주목할 만한 수많은 기능이 라이브러리에 추가**
- 자바는 **메이저 릴리스**마다
  - 새로운 기능을 설명하는 **웹페이지**에 공시

### URL의 내용을 가져오는 명령줄 어플리케이션
- 이전 버전에는 작업하기 어려웠으나,
- `java 9:`에서는 `InputStream::transferTo` 메서드를 사용하여 쉽게 구현
- 코드
  ```java
  public static void main(String[] args) throws IOException {
    try (InputStream in = new URL(args[0]).openStream()) {
      in.transferTo(System.out);
    }
  }
  ```

### 중요한 라이브러리
- 라이브러리가 많기 때문에 모든 API 문서를 공부하기는 벅차겠지만,
  - 적어도, `java.lang`, `java.util`, `java.io`와 그 하위패키지는 익숙해져야 함
- 추가 라이브러리
  - **컬렉션 프레임워크**
  - **스트림 라이브러리**(ITEM.45 ~ 48)
  - `java.util.concurrent`의 **동시성 라이브러리**
    - **멀티스레드 프로그래밍**작업을 단순화해주는 고수준의 편의 기능
    - 고수준 개념을 지적 구현할 수 있도록 도와주는 **저수준 요소**
    - `java.util.concurrent` 관련 라이브러리 ITEM.80, ITEM.81

### 라이브러리를 먼저 사용하기
- 라이브러리가 여러분에게 필요한 기능을 충분히 제공하지 못할 수 있음
  - 전문적인 기능을 요구할수록 맹점이 많음
- **우선은 라이브러리 사용하기**
  - 어떤 영역의 기능을 제공하는지 살펴보기
  - 이후, **원하는 기능**이 아니라 판단되면 **대안**을 사용하기
- 어떤 라이브러리든 제공하는 기능은 유한하며, 빈 구멍이 있음
- **자바 표준 라이브러리**에서 원하는 기능을 찾지 못하면
  - 그 다음 선택지는 **고품질의 라이브러리**
    - 구글의 **구아바 라이브러리**(guava)
- 적합한 서드파티 라이브러리를 찾지 못했다면,
  - 다른 선택이 없으니 직접 구현

### 결론
- 아주 특별한 나만의 기능이 아니라면
  - 누군가 이미 **라이브러리** 형태로 구현해놓았을 가능성이 있음
- 있는지 잘 모르겠으면 우선 **찾아볼 것**
- 일반적으로 **라이브러리 코드**는
  - 직접 작성한 것보다 **품질**이 좋고
  - 점차 **개선**될 가능성이 높음
- **코드 품질**에도 **규모의 경제**가 적용됨
- **라이브러리 코드**는
  - **개발자 각자**가 작성하는 것보다 주목을 많이 받으므로,
  - **코드 품질**도 그만큼 높아짐