## [ITEM.67] 최적화는 신중히
### 최적화 격언(3)
- 맹목적인 어리석음을 포함해, 그 핑계보다 **효율성**이라는 이름 아래 행해진
  - 컴퓨팅 죄악이 더 많다
  - Wulf72
- 전체의 97% 정도인 자그마한 효율성은 모두 잊자.
  - 섣부른 최적화가 만악의 근원이다.
  - Knuth74
- 최적화 할 때는 다음 두 규칙을 따르라
  - 첫번째, 하지마라
  - 두번째, (전문가 한정) 아직 하지 마라
    - 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까진 하지 말 것
  - Jackson75

### 격언에 대한 설명
- java가 나오기 20년 전에 나온 설명
- 최적화의 어두운 진실
- 최적화는
  - 좋은 결과보다, 해로운 결과로 이어지기 쉬우며
  - 섣부르게 하면 특히 더 해당함
- 빠르지도 않고, 제대로 동작하지도 않으면서
  - 수정하기는 어려운 소프트웨어 개발

### 성능때문에
- **성능 때문에 견고한 구조를 희생하지 말 것**
- 빠른 프로그램 보다는 **좋은 프로그램**을 작성하기
- 좋은 프로그램이지만, 원하는 성능이 나오지 않는다면
  - 그 **아키텍처 자체**가 최적화 할 수 있는 길이 있을 것
- 좋은 프로그램은 **정보 은닉**의 원칙을 따르므로
  - 개별 구성요소의 내부를 **독립적**으로 설계할 수 있음
- 시스템의 나머지에 영향을 주지 않고도,
  - 각 요소를 재설계 할 수 있음

### 설계 단계와 성능
- 프로그램을 완성할 때까지, 성능 문제를 무시하라는 뜻은 아님
- 구현상의 문제는 나중에 최적화하여 해결할 수 있지만
  - **아키텍처 결함**이 성능을 제한하는 상황이라면
    - **시스템 전체**를 다시 작성하지 않고는, 해결하기 불가능 할 수 있음
- 완성된 설계의 기본 틀을 변경하려다 보면
  - **유지보수**하거나 개선하기 어려운 **꼬인 구조의 시스템**이 만들어지기 쉽기 때문
- 따라서 **설계 단계**에서 **성능**을 염두해 두어야 함

### 성능을 제한하는 설계를 피하기
- 완성 후 변경하기가 가장 어려운 **설계 요소**는
  - 바로 컴포넌트 끼리, 혹은 외부 시스템과의 **통신 방식**이다.
- API, 네트워크 프로토콜, 영구 저장용 데이터 포맷등이 존재
- 이런 설계 요소들은
  - 완성 후에는 변경하기 **어렵거나, 불가능**할 수 있으며
  - 동시에 시스템 성능을 심각하게 **제한**할 수 있음

### API 설계 시, 성능에 주는 영향 고려
- `public` 타입을 **가변**으로 만들면
  - 내부 데이터를 변경할 수 있게 만들면,
  - 불필요한 **방어적 복사**를 많이 유발할 수 있음(ITEM.50)
- **composition**으로 해결할 수 있음에도
  - 상속으로 설계한 `public` 클래스는,
  - 상위 클래스에 영원히 **종속**되며
    - 그 성능 제약도 물려받게 된다.(ITEM.18)
- **인터페이스**도 있는데, 굳이 **구현 타입**을 사용하는 것도 좋지 않음
  - 특정 구현체에 **종속**되게 하여
  - 나중에 더 빠른 구현체가 나오더라도, 이용하지 못하게 됨(ITEM.64)

### API와 성능
- API가 성능에 주는 영향은 현실적인 문제
- `java.awt.Component` 클래스의 `getSize` 메서드
  - 이 API 설계자는, 이 메서드가 `Dimension` 인스턴스를 반환하도록 함
  - `Dimension`은 **가변**으로 설계되었으며,
    - `getSize`를 호출하는 모든 곳에서, `Dimension` 인스턴스를 **방어적으로 복사**하느라 새로 생성해야 함
  - 요즘 VM의 경우 작은 객체를 몇 개 생성하는게 부담은 되지 않겠지만
    - 수백만개의 경우 상황이 달라짐
- 이 API를 다르게 설계했을 수도 있음
  - `Dimension`을 불변(ITEM.17)으로 만드는게 제일 이상적이나,
  - `getSize`를 `getWidth`와 `getHeight`로 나누는 방법도 존재
    - `Dimension` 객체의 기본 타입 값들을 **따로따로 반환**
  - `java 2`의 경우, 성능 문제를 해결하고자
    - `Component` 클래스에 이 메서드를 추가 함
  - 기존 클라이언트 코드는, 여전히 `getSize` 메서드를 호출하며
    - 기존 잘못된 API 설계의 피해를 보고 있음

### 성능을 위해 API를 왜곡하지 말 것
- 잘 설계된 API의 경우, 성능도 좋은게 보통
- API를 왜곡하도록 만든 그 성능 문제는
  - 해당 플랫폼이나, 아랫단 소프트웨어의 다음버전에서 사라질 수도 있으나,
- 왜곡된 API와 이를 지원하는 비용은 계속됨
- 신중하게 설계 하여,
  - 명확한 구조를 갖춘 프로그램을 완성한 다음에야, **최적화**를 고려
  - 단, 성능에 만족하지 못할 경우에 한정

### 새로운 최적화 규약
- **각각의 최적화 시도 전후로 성능을 측정하기**
- 시도한 최적화 기법이
  - 성능을 눈에 띄게 높이지 못하는 경우가 많으며
  - 더 나빠지게 할 때도 있음
- 주요 원인은
  - 프로그램에서 시간을 잡아먹는 부분을 **추측하기 어렵기** 때문
- 느릴꺼라 짐작한 부분이, 성능에 별다른 영향을 주지 않은 곳이라면
  - 불필요한 작업을 한 꼴
- 일반적으로 `90%`의 시간을
  - 단 `10%`의 코드에서 사용한다는 것을 기억할 것

### 프로파일링 도구의 사용
- **profiling tool**은 최적화 노력을 어디에 집중할지 도움을 준다.
- 개별 메서드의 **소비 시간**과 **호출 횟수**와 같은
  - **Runtime** 정보를 제공하여
  - 집중할 곳 뿐만 아니라,
    - 알고리즘을 변경해야 한다는 사실을 가이드 해줌
- 프로그램에서 시간이 거듭제곱으로 증가하거나 더 나쁜 알고리즘이 숨어있다면
  - 교체해야 할 것
- 다른 튜닝을 하지 않아도, 문제가 사라질 것
- 시스템 규모가 커질 수록 프로파일러가 더 중요해짐
- **`jmh`도 좋은 도구**
  - 프로파일러는 아니지만
  - 자바 코드의 **상세한 성능**을 알기 쉽게 보여주는
  - **마이크로 벤치마크 프레임워크**

### 자바에서의 성능 측정
- 최적화 시도 전후의 성능 측정은
  - C와 C++과 같은 전통적인 언어에서도 중요하지만,
  - 성능 모델이 덜 정교한 자바에서는 **중요성**이 더욱 크다
- 자바는 기본 연산에 드는 **상대적인 비용**을 덜 명확하게 정의
- **프로그래머가 작성하는 코드**와 **CPU에서 수행하는 명령** 사이의
  - **추상화 격차**가 커서
    - 최적화로 인한 **성능 변화**를 일정하게 예측하기가 어려움
- 그렇기 때문에
  - 최적화와 관련해, 일부만 맞거나 터무니 없는 머신들이 많음

### 자바의 성능 모델과 불명확성
- 자바의 성능 모델은 **정교하지 않음**
  - 구현 시스템, 릴리스, 프로세서 마다 차이가 존재
- 개발한 프로그램을
  - 여러 가지 **자바 플랫폼**이나, 여러 **하드웨어 플랫폼**에서 구동한다면
  - **최적화**의 효과를 각각에서 측정해야 함
- 그러다 보면, 다른 구현 또는 하드웨어 플랫폼 사이에서
  - 성능을 **타협**해야 하는 상황도 존재
- **측정**은 중요하다

### 정리
- 빠른 프로그램을 작성하려 많은 비용을 쏟지 말 것
- 좋은 프로그램을 작성하다 보면, **성능은 따라옴**
- 하지만 **시스템 설계**시
  - 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 설계시,
    - **성능**을 꼭 염두해 두어야 함
- **시스템 구현**을 완료 했다면, **성능 측정**
  - 충분히 빠르면 끝내기
- 그렇지 않다면,
  - **프로파일러**를 사용하여
    - 문제의 원인이 되는 지점을 파악하여 **최적화**
- 가장 먼저 **어떤 알고리즘**을 사용했는지 확인
  - 알고리즘이 잘못 되었다면
    - 다른 **저수준 최적화**는 필요가 없음
- 만족할 때까지 과정을 반복하고,
  - 변경 후에는 **성능 측정**은 필수