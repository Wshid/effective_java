## [ITEM.41] 타입 정의시 마커 인터페이스 사용

### 마커 인터페이스(marker interface)
- 메서드가 존재하지 않음
- 자신을 구현하는 클래스가
  - **특정 속성을 가짐을 표현**해주는 인터페이스
- `Serializable`
  - 자신을 구현한 클래스의 인스턴스는
    - `ObjectOutputStream`을 통해 write
      - **serialization**이 가능하다는 의미

### 마커 인터페이스의 첫번째 장점 - 마커 애너테이션과 비교를 통한
- **마커 인터페이스**는
  - 이를 구현한 클래스의 인스턴스를 구분하는 **타입**으로 사용 가능
- **마커 애너테이션**은 불가
- **마커 인터페이스**는 **타입** 이다.
  - **마커 애너테이션**을 사용했다면 `Runtime`에 발생할 오류를
  - `Compile Time`에 잡을 수 있음
- 자바의 **직렬화**는 `Serializable` 마커 인터페이스를 보고
  - 그 대상이 **직렬화**가능한 **타입**인지 확인
- 예시
  - `ObjectOutputStream.writeObject` 메서드의 경우
    - 인수로 받은 객체가 당연히 `Serializable`을 구현했을 것이라 가정
    - 하지만 실제는, `Serializable`이 아닌 `Object` 객체를 받도록 설계
  - **직렬화**할 수 없는 객체를 넘겨도
    - `Runtime`이 되어야 문제를 확인할 수 있음
  - **마커 인터페이스**를 사용하는 주요 이유가 **컴파일 타임 오류 검출**
    - 위 예시에는 그 이점을 살리지 못함

### 마커 인터페이스의 두번째 장점 - 마커 애너테이션과 비교를 통한
- 적용 대상을 더 **정밀하게** 지정할 수 있다.
- 적용 대상(`@Target`)을 `Element.TYPE`으로 선언한 **애너테이션**은
  - 모든 타입(클래스, 인터페이스, 열거타입, 애너테이션)에 달 수 있음
    - 부착할 수 있는 **타입**을 세밀하게 제한 하지는 못한다.
- 만약, **특정 인터페이스**를 구현한 **클래스에만** 적용하고 싶은 **마커**가 있다면
  - **마커**를 인터페이스로 정의시,
    - 마킹하고 싶은 클래스에서만, 그 인터페이스를 구현(**인터페이스 확장**)하면 됨
    - 마킹된 타입의 경우 자동으로 **인터페이스**의 하위 타입이 보장 됨
- `Set` 인터페이스
  - 일종의 제약이 있는 **마커 인터페이스**
  - `Set`은 `Collection`의 하위 타입에만 적용 가능
  - `Collection`이 정의한 메서드 외에 새롭게 추가된 것이 없음
  - `Set`을 보통은 **마커 인터페이스**라고 생각을 안하지만,
    - `add`, `equals`, `hashCode` 등 `Collection`의 메서드 몇 개의 규약을 살짝 수정했기 때문
  - 하지만, 특정 인터페이스 **하위 타입**에만 적용 가능하며
    - 아무 규약에도 손대지 않은 **마커 인터페이스**는 충분히 존재
  - 이러한 마커 인터페이스는
    - **객체**의 특정 부분을 **불변식**(invariant)로 규정하거나,
    - 그 타입의 **인스턴스**는 
      - **다른 클래스의 특정 메서드**가 처리할 수 있는 **사실을 명시**하는 용도로 사용 가능
      - `Serializable` 인터페이스가 `ObjectOutputStream`이 처리할 수 있는 **인스턴스**를 명시

### 마커 애너테이션의 장점 - 마커 인터페이스와 비교를 통한
- 거대한 애너테이션 시스템의 지원
  - 애너테이션을 적극 활용하는 **프레임워크**에서는
    - 마커 애너테이션이 **일관성**을 지키는데 유리

### 마커 인터페이스/애너테이션 사용처
- 마커 애너테이션
  - **클래스**와 **인터페이스**외의 **프로그램 요소**(모듈, 패키지, 필드, 지역변수 등)에 마킹
    - 클래스와 인터페이스만이
      - **인터페이스**를 구현하거나, 확장할 수 있기 때문
  - 애너테이션을 많이 사용하는 프레임워크일 때
- 마커 인터페이스
  - 마커를 **클래스**나 **인터페이스**에 적용시
    - 이 마킹이 된 객체를 **매개변수**로 받는 **메서드**를 작성할 일이 있을지 자문
      - "그렇다"일 시, **마커 인터페이스**를 사용
  - 마커 인터페이스를 해당 메서드의 **매개변수 타입**으로 사용하여 **컴파일 오류**를 잡을 수 있기 때문
  - 이런 메서드를 사용할 일이 없다면, **마커 애너테이션** 사용

### 결론
- **마커 인터페이스**와 **마커 애너테이션**은 각자의 사용처가 있음
- **마커 인터페이스 사용**
  - 새로 추가하는 메서드 없이, 단지 **타입 정의**가 목적일 때  
- **마커 애너테이션 사용**
  - 클래스나 인터페이스외 **프로그램 요소**에 마킹
  - **애너테이션을 적극 활용하는 프레임워크**의 일부로 마커 편입시 사용
- 적용 대상이 `ElementType.TYPE`인 **마커 애너테이션** 사용시,
  - 애너테이션으로 구현하는게 옳은지, **마커 인터페이스**가 나을지 고려해야 함
- **타입을 정의할 거라면 인터페이스를 쓰라**
  - 타입을 정의할 게 아니라면 인터페이스를 쓰지 말라(**ITEM.22**)와 상충되는 내용