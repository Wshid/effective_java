## [ITEM.85] 자바 직렬화의 대안 찾기

### 객체 직렬화
- 자바가
  - `객체 -> 바이트스트림`으로 **인코딩**(직렬화) 하고
  - `바이트 스트림 -> 객체`로 **재구성**(역직렬화) 매커니즘
- 직렬화된 객체는
  - 다른 VM에 전송하거나,
  - 디스크에 저장한 후, 추후 **역직렬화**가 가능
- 하지만, 직렬화가 품고 있는 **위험**이 존재
  - 이를 최소화 하는 방법?

### 직렬화의 도입
- 1997년에 자바에 처음으로 직렬화 도입
- 프로그래머가 어렵지 않게 **분산 객체**를 만들수 있음
- 하지만 단점 존재
  - 보이지 않는 생성자
  - API와 구현 사이의 모호한 경계
  - 잠재적인 정확성
  - 성능, 보안, 유지보수
- 그래도 직렬화는 장점이 크다

### 직렬화의 근본적인 문제
- **공격 범위**가 너무 넓고, 지속적으로 넓어져 방어하기 어려움
- `ObjectInputStream::readObject`메서드 호출시,
  - 객체 그래프가 **역직렬화**되기 떄문
- `readObject` 메서드는
  - `Serializable` 인터페이스를 구현했다면,
  - `ClassPath` 안의 거의 모든 타입의 객체를 만들어 낼 수 있는
    - 마법같은 생성자
- **바이트 스트림**을 역직렬화하는 과정에서
  - 이 메서드는, 그 타입들 안의 **모든 코드 수행**이 가능함
  - 그 타입들의 코드 전체가 **공격 범위**가 될 수 있다

### 역직렬화의 위험
- 자바의 표준 라이브러리, `apache.commons`, `third party` 및
  - app 자신 클래스도, 위에서 말한 **공격 범위**에 포함
- 관련한 모든 모범 사례를 따르고,
  - 모든 **직렬화 가능 클래스**들을 공격에 대비한다 해도,
  - app은 여전히 취약할 수 있음
- `Robert Seacord`의 조언
  - **역직렬화**는 명백하고, 현존하는 위험
  - 애플리케이션에서 **직접**혹은 자바 하부시스템을 통해 간접적으로 쓰이고 있기 때문
    - 자바 하부 시스템
      - RMI(Remote Method Invocation)
      - JMX(Java Management Extension)
      - JMS(Java Messaging System)
  - 신뢰할 수 없는 **스트림**을 **역직렬화**하면 다음과 같은 문제 발생
    - RCE(Remote Code Execution)
    - DoS(Denial-of-Service)
  - 잚소한게 없는 app이라도, 위 공격에 취약해 질 수 있음

### 바이트 스트림의 역직렬화는 신중하게
- **공격자**와 **보안전문가**는
  - 자바 라이브러리와 널리 쓰이는 서드파티 라이브러리에서
  - **직렬화 가능 타입**들을 연구하여
    - **역직렬화** 과정에서 호출되어
    - 잠재적으로 위험한 동작을 수행하는 메서드를 확인
  - 이런 메서드를 **가젯**(gadget)이라 부름
- 여러 가젯을 함께 사용하여, **체인**을 구성할 수 있음
  - 가끔씩 공격자가 기반 하드웨어의 **네이티브 코드**를 맘대로 실행할 수 있는
    - 강력한 **가젯 체인**도 존재
- 따라서, 아주 신중하게 제작한 **바이트 스트림**만 **역직렬화**해야 함
- 샌프란 시스코 교통국을 마비시킨 공격이 위의 사례
  - 가젯들이 체인으로 엮어 피해가 컷다

### 역직렬화 폭탄
- **역직렬화**에 **시간이 오래 걸리는 짧은 스트림**을
  - 역직렬화 하는 것만으로, `DoS`에 노출될 수 있음
- 이런 스트림을 **역직렬화 폭탄**(`deserialization bomb`)라 함
- 코드 예시
  ```java
  static byte[] bomb() {
      Set<Object> root = new HashSet<>();
      Set<Object> s1 = root;
      Set<Object> s2 = new HashSet<>();
      for(int i = 0; i < 100; i++) {
          Set<Object> t1 = new HashSet<>();
          Set<Object> t2 = new HashSet<>();
          t1.add("foo"); // t1과 t2를 다르게 만듦
          s1.add(t1); s1.add(t2);
          s2.add(t1); s2.add(t2);
          s1 = t1;
          s2 = t2;
      }
      return serialize(root); // 간결하게 하기 위해, 이 메서드의 코드 생략
  }
  ```
- 위 객체 그래프는 `201`개의 `HashSet` 인스턴스로 구성
  - 각각은 `3`개 이하의 **객체 참조**를 가짐
- 스트림의 전체 크기는 5,744 byte지만,
  - **역직렬화**는 끝나지 않을 것
- 위 코드의 문제는
  - `HashSet` 인스턴스를 **역직렬화**하려면
  - 그 원소들의 `HashCode`를 계산해야 한다는 것
- 루트 `HashSet`에 담긴 **두 원소**는 각각
  - 루트와 동일하게, 다른 `HashSet` 2개씩을 원소로 갖는 `HashSet`
- 그리고 반복문에 의해 이 구조가 깊이 `2^100`번 넘게 호출해야 함
- **역직렬화**가 영원한것도 문제지만
  - 무언가 잘못되었다는 **신호가 없음**
- 이 코드는 단 몇 개의 객체만 생성해도
  - **스택 깊이 제한**에 걸린다

### 문제 해결 방법
- 애초에 신뢰할 수 없는 **바이트 스트림**을 **역직렬화**하는 일 자체가
  - 공격에 노출되는 행위
- **직렬화 위험을 회피**하는 가장 좋은 방법은
  - 아무것도 **역직렬화**하지 않는 것
- 작성하는 새로운 시스템에서
  - **자바 직렬화**를 써야할 이유가 없음
- **객체**와 **바이트 시퀀스**를 변환해주는 다른 매커니즘이 많음
  - 자바 직렬화의 여러 위험을 회피하면서
  - 다양한 플랫폼 지원, 우수한 성능, 풍부한 지원도구, 활발한 커뮤니티 등
    - 다른 이점이 많음
  - 위 내용을 **크로스-플랫폼 구조화된 데이터 표현**(cross-platform structured-data representation)이라 함

### cross-platform structured-data representation
- 자바 직렬화보다 훨씬 간단 함
- 임의 객체를 자동으로 **직렬화/역직렬화**하지 않음
- 대신 **속성-값** 쌍의 집합으로 구성된
  - 간단하고, 구조화된 **데이터 객체**를 사용
- 또한, **기본 타입** 몇개와, **배열 타입**만 지원
- 간단한 추상화 만으로도,
  - 강력한 분산시스템을 구축하기에 충분하며,
  - 자바 직렬화의 심각한 문제를 회피할 수 있음

### cross-platform structured-data representation의 예시
- JSON, 프로토콜 버퍼(protocol buffers, protobuf)
  - JSON : **브라우저**와 **서버**의 통신용으로 설계
  - 프로토콜 버퍼 : 구글이 **서버 사이에 데이터 교환 및 저장**하기 위해 설계
- 위 두가지를 **언어 중립적**이라고 하지만,
  - JSON은 **자바스크립트**용으로,
  - 프로토콜 버퍼는 **C++**용으로 만들어 졌으며, 그 흔적이 남아 있음

### JSON vs protobuf
- **JSON**
  - 텍스트 기반이기 때문에 **사람이 읽을 수 있음**
  - 오직 데이터만을 표현하는데 사용
- **protobuf**
  - 이진 표현이라 **효율이 높음**
  - 문서를 위한 스키마(타입)을 제공하고, 올바르게 쓰도록 강요
  - 이진 표현뿐 아니라 사람이 읽을 수 있는 **텍스트 표현**(pbtxt)도 지원

### 레거시 때문에 자바 직렬화를 회피할 수 없는 경우
- 레거시 시스템 때문에, **자바 직렬화**를 완전히 배제 불가능 할 때,
  - 신뢰할 수 없는 데이터는 **절대 역직렬화 하지 말 것**

### 역직렬화 필터링
- 직렬화를 피할 수 없고,
  - 역직렬화한 데이터가 **안전한지 확신할 수 없을 때**
- 역직렬화 필터링(`java.io.ObjectInputFilter`)를 사용
- `java 9:`, 이전버전에서 사용가능하도록 이식됨
- 객체 역직렬화 필터링은
  - **데이터 스트림**이 **역직렬화**되기 전에, **필터**를 설치하는 기능
- **클래스** 단위로,
  - 특정 클래스를 받아들이거나, 거부할 수 있음
  - **기본 수용** 모드에서
    - `blacklist`에 기록된, 잠재적으로 위험한 클래스를 거부함
  - **기본 거부** 모드에서
    - `whitelist`에 기록된 안전하다고 알려진 클래스들만 수용
- `blacklist`보다 `whitelist`방식을 추천
  - `blacklist`의 경우, 기존에 알려진 내용만 방어할 수 있기 때문
- SWAT(Serial Whitelist Application Trainer) 도구
  - 사용자 app을 위한, `whitelist`를 자동으로 생성
- 필터링 기능은
  - 메모리를 **과하게 사용**하거나
  - 객체 그래프가 **너무 깊어지는** 사태를 보호함
- 하지만 **직렬화 폭탄**은 방어 불가능

### 조언
- 직렬화는 자바 생태계에서 많이 쓰이고 있으나,
  - 되도록 **크로스-플랫폼 구조화된 데이터 표현**으로 전환할 것
- 현실적인 이유로 불가능 하다면
  - **직렬화 가능 클래스**를 올바르고, 안전하게 효율적으로 작성해야 하며, 상당한 주의 필요

### 정리
- **직렬화**는 위험하므로 회피할 것
- 시스템을 밑바닥부터 설계한다면
  - `JSON`이나 `protobuf`과 같은 대안을 사용할 것
- 신뢰할수 없는 데이터는 **역직렬화**하지 말 것
- 꼭 해야한다면 **역직렬화 필터링**을 사용하되,
  - 이 역시 모든 공격을 방어하지는 못함
- 클래스가 **직렬화**를 지원하도록 하지 말고,
  - 꼭 그래야 한다면, 정말 신경써서 작성하기