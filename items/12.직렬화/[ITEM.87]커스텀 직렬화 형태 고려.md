## [ITEM.87] 커스텀 직렬화 형태 고려

### 선 작업 후 유지보수 전략 - Serializable
- 어떤 기능을 만들 때,
  - 다음 릴리스에서 제대로 다시 구현하기로 하고,
  - 이번 릴리스에서는 동작만 하도록 하는 것
- 보통은 크게 문제되지 않으나,
  - 클래스가 `Serializable`을 구현하고, **기본 직렬화 형태**를 사용한다면,
    - 다음 릴리스때 **기본 직렬화 형태**를 버릴 수 없게 된다.
- 다음 릴리스 때 버리려 한 현재의 구현에
  - 영원히 종속되는 형태
  - 기본 직렬화를 버릴 수 없음
- 실제로도 `BigInteger`와 같은
  - 일부 자바 클래스가 가지고 있는 문제

### 괜찮을 때만 기본 직렬화 형태 사용
- 고민 이후, 괜찮다고 판단될때만,
  - **기본 직렬화 형태**를 사용할 것
- **기본 직렬화 형태**는
  - **유연성**, **성능**, **정확성** 측면에서
    - 신중히 고민한 후, 합당할때만 사용해야 함
- 일반적으로, 직접 설계하더라도,
  - **기본 직렬화 형태와 같은 결과**가 나올 때만, 기본 형태를 사용해야 함
- 어떤 객체의 **기본 직렬화 형태**는
  - 그 객체를 `root`로 하는 객체 그래프의 **물리적 모습**을
  - 나름 효율적으로 인코딩 한다.
- 객체가 포함된 **데이터**들과
  - 그 객체에서부터 시작해 **접근할 수 있는 모든 객체**를 담고,
  - 심지어, 이 객체들이 연결된 `topology`(위상)까지 기술
- 아쉽게도, **이상적인 직렬화 형태**라면
  - **물리적인 모습**과 **논리적인 모습**만을 표현해야 함

### 객체의 물리적 표현과 논리적 내용이 동일 할 때
- 객체의 **물리적 표현**과 **논리적 내용**이 같다면,
  - **기본 직렬화 형태**를 써도 무방
- 기본 직렬화에 이상적인 코드
  ```java
  public class Name implements Serializable {

    /**
      * 성, null이 아니어야 함
      * @serial
      **/
    private final String lastName;

    /**
      * 이름, null이 아니어야 함
      * @serial
      **/
    private final String firstName;

    /**
      * 중간이름, 중간 이름이 없다면 null
      * @serial
      **/
    private final String middleName;
    ...
  }
  ```
- 이름은 논리적으로 `이름`, `성`, `중간이름`이라는 `3개의 문자열`로 구성되며,
  - 앞 코드의 **인스턴스 필드**는 위 논리적 구조를 정확히 반영함

### readObject의 사용
- **기본 직렬화 형태**가 적합하다고 결정했더라도,
  - **불변식 보장**과 **보안**을 위해 `readObject` 메서드를 제공할 때가 많음
- 앞의 `Name` 클래스의 경우,
  - `readObject` 메서드가, `lastName`과 `firstName` 필드가 `null`이 아님을 보장해야 함
- ITEM.88, ITEM.90

### 문서화 주석
- `Name`의 세 필드 모두 `private`임에도 **문서화 주석**이 달려있음
- 클래스의 **직렬화 형태**에 포함되는 **공개 API**에 속하며,
  - 공개 API는 모두 문서화 해야하기 때문
- `private` 필드의 설명을 **API 문서**에 포함하라고 javadoc에 알려주는 역할은
  - `@serial` 태그
- `@serial` 태그로 기술한 내용은
  - API 문서에서 **직렬화 형태**를 설명하는 특별한 페이지에 기록됨

### 직렬화에 적합하지 않은 예
- 문자열 리스트를 표현
  - 물론 `List` 구현체를 사용하면 더 이상적으로 표현은 가능하나, 여기서는 논외
- 코드
  ```java
  public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;

    private static class Entry implements Serializable {
      String data;
      Entry next;
      Entry previous;
    }
    // ... 나머지 코드 생략
  }
  ```
- 논리적으로 위 클래스는 `일련의 문자열`을 표현
- 물리적으로는 **문자열**들을 **이중 연결 리스트**로 표현
- 이 클래스에, **기본 직렬화 형태**를 사용하면
  - 각 노드의 양방향 연결정보를 포함해
  - 모든 `Entry`를 철두철미하게 기록해야 함

### 객체의 물리적표현과 논리적 표현의 차이가 클 경우 발생하는 문제(4)
- 객체의 **물리적 표현**과 **논리적 표현**의 차이가 클 때
  - **기본 직렬화 형태**를 사용하면 4가지 문제 발생
#### 1. 공개 API가 현재 내부 표현방식에 영원히 종속
- `private` 클래스인 `StringList.Entry`가 **공개 API**가 됨
- 다음 릴리스에서, **내부 표현 방식**을 바꾸더라도
  - `StringList` 클래스는 여전히 **연결리스트**로 표현된 입력도 처리할 수 있어야 함
- 연결 리스트를 더는 사용하지 않더라도,
  - 관련 코드를 절대 제거할 수 없음

#### 2. 너무 많은 공간 차지
- 위 예의 직렬화 형태는
  - **연결 리스트**의 모든 엔트리와 연결정보까지 기록했지만,
  - **엔트리**와 **연결정보**는 내부 구현에 해당하므로
    - **직렬화 형태**에 포함할 가치가 없음
- 이처럼 직렬화 형태가 너무 커져서
  - **디스크**에 저장하거나 **네트워크 전송**에서 속도가 느려짐

#### 3. 시간 소요 증가
- 직렬화 로직은 **객체 그래프**의 위상에 관한 정보가 없기 때문에
  - 그래프를 직접 순회할 수 밖에 없음
- 앞 예에서는, 간단히 **다음 참조**를 가보는 정도로 충분함

#### 4. stack overflow
- 기본 직렬화 과정은 **객체 그래프**를 **재귀 순회**
  - 중간 정도 크기의 **객체 그래프**에서도 자칫, `stack overflow` 발생 가능성 존재
- 한 컴퓨터에서는
  - `StringList`에 원소를 `1,000 ~ 1,800`개 정도 담으면
  - 직렬화 과정에서 `StackOverflowError`가 발생함
- 위 컴퓨터에서 `stack overflow`를 일으키는 최소 크기가 실행할때마다 달라지기도 함
- 이 문제를 일으키는 데 필요한 **리스트의 최소 크기**는
  - **플랫폼 구현**꽈 **명령줄 플래그**에 따라 달라짐
- 어떤 플랫폼에서는 문제가 발생하지 않을 수 있음

### StringList를 위한 합리적인 직렬화 형태
- 단순히 **리스트**가 포함한 문자열의 개수를 적은 다음,
  - 그 뒤로 문자열들을 나열하는 수준이면 됨
- `StringList`의 **물리적인 상세 표현**은 배제한 채
  - **논리적인 구성**만 담는 것
- 예시
  - `writeOBject`와 `readObject`가 직렬화를 처리
  - 일시적이란 뜻의 `transient` 한정자는
    - 해당 인스턴스 필드가, **기본 직렬화 형태**에 포함되지 않음을 의미
  ```java
  public final class StringList implements Serializable {
    private transient int size = 0;
    private transient Entry head = null;

    // 직렬화 되지 않음
    private static class Entry {
      String data;
      Entry next;
      Entry previous;
    }

    // 지정한 문자열을 리스트에 추가
    public final void add(String s) { ... }

    /**
      * 이 {@code StringList} 인스턴스를 직렬화 한다.
      *
      * @serialData 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후
      * ({@code int}), 이어서 모든 원소를(각각은 {@code String})
      * 순서대로 기록한다.
      **/
    private void writeObject(ObjectOutputStream s) throws IOException {
      s.defaultWriteObject();
      s.writeInt(size);

      // 모든 원소를 올바른 순서대로 기록
      for(Entry e = head; e != null; e = e.next)
        s.writeObject(e.data);
    }

    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
      s.defaultReadObjecT();
      int numElements = s.readInt();

      // 모든 원소를 읽어 이 리스트에 삽입
      for(int i=0; i < numElements; i++)
        add((String) s.readObject());
    }
    
    ...
  }
  ```
  - `StringList`의 필드 모두가 `transient`더라도
    - `writeObject`와 `readObject`는 각각 먼저 `defaultWriteObject`와 `defaultReadObject`를 호출
  - 클래스의 인스턴스 필드 모두가 `transient`면
    - `defaultWriteObject`와 `defaultReadObject`를 호출하지 않아도 된다고 들었을지 모르지만,
    - **직렬화 명세**는 이 작업을 무조건 하라고 요구함
    - 이래야, 향후 릴리스에서 `transient`가 아닌 **인스턴스 필드**가 추가되더라도
      - 상호(상위/하위) 호환이 되기 때문
    - 신버전 인스턴스를 **직렬화**한 후, 구버전으로 **역직렬화**하면
      - 새로 추가된 필드들은 **무시**됨
  - 구버전 `readObject` 메서드에서, `defaultReadObject`를 호출하지 않는다면,
    - 직렬화할 때, `StreamCorruptedException`이 발생

### writeObject의 주석
- `writeObject`는 `private` 메서드임에도 **문서화 주석**이 달려 있음
- `Name` 클래스의 `private` 필드에 **문서화 주석**을 단 이유의 연장선
- 이 `private` 메서드는
  - 직렬화 형태에 포함되는 **공개 API**에 속하며,
  - 공개 API는 모두 문서화해야 한다.
- 필드용의 `@serial` 태그처럼
  - 메서드에 달른 `@serialData` 태그는
  - javadoc 유틸리티에게, 이 내용을 **직렬화 형태 페이지**에 추가하도록 요청하는 역할

### 개선 후 효과 - 성능
- 문자열들의 길이가 평균 `10`이라면,
  - 개선 버전의 `StringList`의 직렬화 형태는
  - 원래 버전의 **절반 정도**
    - 약 2배정도 빠르게 수행
- 개선된 `StringList`의 경우, `stack overflow`가 전혀 발생하지 않아,
  - 실질적으로 직렬화 할 수 있는 크기 제한이 없어짐

### 기본 직렬화의 안좋은 예시
- `StringList`도 기본 직렬화 형태는 적합하지 않았으나,
  - 훨씬 심한 클래스도 많이 존재
- `StringList`의 기본 직렬화 형태는
  - 비록 **유연성**과 **성능**이 떨어졌더라도,
  - 객체를 **직렬화**후 **역직렬화**시, 원래 객체를 **불변식**까지 포함하여 제대로 복원해낸다는 점에서 정확
  - 하지만 그 **불변식**이 세부 구현에 따라 달라지는 객체에서는 이 **정확성**마저 깨질 수 있음
- 해시 테이블 예시
  - **해시 테이블**은 물리적으로 **키-값 엔트리**들을 담은 **해시 버켓**을 차례로 나열한 형태
  - 어떤 **엔트리**를 어떤 **버킷**에 담을지는
    - **키**에서 구한 **해시코드**가 결정하는데,
    - 그 계산 방식은 **구현**에 따라 달라질 수 있음
    - 계산 할때마다 달라지기도 함
  - 따라서 **해시 테이블**에 **기본 직렬화**를 사용하면, **심각한 버그 발생 우려**
    - 해시 테이블을 **직렬화** 후 **역직렬화**하면
      - **불변식**이 심하게 훼손된 객체가 생성될 수 있음

### defaultWriteObject 메서드 호출
- **기본 직렬화**를 수용하든 하지 않든,
  - `defaultWriteObject` 메서드를 호출하면
  - `transient`로 선언하지 않은 모든 **인스턴스 필드**가 직렬화
- 따라서 `transient`로 선언해도 되는 **인스턴스 필드**에는
  - 모두 `transient` 한정자를 붙여야 함
- **캐시된 해시 값**처럼
  - 다른 필드에서 **유도되는 필드**도 여기에 해당 됨
- JVM을 실행할때마다 **값이 달라지는 필드**도 마찬가지인데,
  - **네이티브 자료구조**를 가리키는 `long`필드가 여기에 속함
- 해당 객체의 **논리적 상태**와 무관한 필드라고 확신할 때만
  - `transient` 한정자를 생략해야 함
- **커스텀 직렬화 형태**를 사용한다면,
  - 앞서의 `StringList`처럼
  - 대부분의 혹은 모든 인스턴스 필드를 `transient`로 선언해야 함

### 기본 직렬화와 transient
- 기본 직렬화를 사용한다면 `transient` 필드들은
  - **역직렬화**될 때, 기본값으로 **초기화**
    - 객체 참조 필드 : `null`
    - 숫자 기본 타입 필드 : `0`
    - `boolean` : `false`
- 기본값을 그대로 사용해서 안된다면,
  - `readObject` 메서드에서 `defaultReadObject`를 호출한 다음,
    - 해당 필드를 **원하는 값**으로 **복원**(ITEM.88)
  - 혹은 그 값을 처음 사용할 때 **초기화**하는 방법(ITEM.83)

### 동기화 매커니즘과 직렬화
- 기본 직렬화 사용여부와 상관없이
  - 객체의 **전체 상태**를 읽는 메서드에 적용해야 하는 **동기화 매커니즘**을
    - **직렬화**에도 적용해야 함
- 예를들어
  - 모든 메서드를 `synchronized`로 선언하여, 스레드 안전하게 만든 객체(ITEM.82)에서 **기본 직렬화**를 사용하려면
  - `writeObject`도 다음 코드처럼 `synchronized`로 선언해야 함
- 예시 코드
  ```java
  private synchronized void writeObject(ObjectOutputStream s) throws IOException {
    s.defaultWriteObject();
  }
  ```
- `writeObject`메서드 안에서 동기화하고 싶다면,
  - 클래스의 다른 부분에서 사용하는 **락 순서**를 똑같이 따라해야 함
- 그렇지 않을경우, **자원 순서 교착 상태**(resource-ordering deadlock)이 발생할 수 있음

### 직렬버전 UID의 명시적 사용
- 어떤 직렬화 형태를 택하든
  - **직렬화 가능 클래스** 모두에 **직렬버전 UID**를 명시적으로 부여해야 함
- **직렬 버전 UID**가 일으키는 **잠재적인 호환성** 문제가 사라짐(ITEM.86)
- 성능도 조금 빨라지는데,
  - 직렬 버전 UID를 명시하지 않으면
  - `Runtime`에 이 값을 생성하기 위해, **복잡한 연산**을 수행하기 때문
- 선언은, 아래와 같이 한줄 추가하면 됨
  ```java
  private static final long serialVersionUID = <무작위로 고른 long value>;
  ```
- **새로 작성하는 클래스**에서는, 어떤 `long`값이든 상관 없음
- 클래스 일련 번호를 생성해주는 `serialver` 유틸리티를 그대로 사용해도 되며,
  - 생각나는 아무값도 괜찮음
- **직렬버전 UID**가 꼭 **고유할 필요는 없음**
- 직렬 버전 UID가 없는 **기존 클래스**를
  - 구버전으로 직렬화된 **인스턴스**와 **호환성**을 유지한 채 수정하고 싶다면,
    - 구버전에서 사용한 **자동 생성 값**을 그대로 사용해야 함
  - 이 값은, 직렬화된 인스턴스가 존재하는 **구버전 클래스**를
    - `serialver` 유틸리티에 입력으로 주어 실행하면 얻을 수 있음
- 기존 버전 클래스와의 호환성을 끊고 싶다면
  - 단순히 **직렬 버전 UID**값을, 바꾸면 된다.
  - 이렇게 되면, 기존 버전의 **직렬화된 인스턴스**를 역직렬화 할 때
    - `InvalidClassException`이 발생
- **구버전**으로 직렬화된 인스턴스들과의 **호환성**을 제거하는 목적이 아니라면,
  - **직렬 버전 UID**를 수정하지 말 것

### 정리
- 클래스를 **직렬화**하기로 했다면(ITEM.86)
  - 어떤 직렬화 형태를 사용할지 고민해야 함
- 자바의 **기본 직렬화 형태**는
  - 객체를 직렬화한 결과가 해당 객체의 **논리적 표현**에 부합할 때만 사용하고,
  - 그렇지 않다면, 객체를 적절히 설명하는 **커스텀 직렬화 형태**를 고안할 것
- 직렬화 형태도 **공개 메서드**(ITEM.51)를 설계할 때 준하는 시간을 들여 설계해야 함
- 한번 공개된 메서드는 향후 릴리스에서 제거할 수 없듯,
  - **직렬화 형태**에 포함된 **필드**도 맘대로 **제거 불가능**
  - **직렬화 호환성**을 유지하기 위해, 영원히 지원해야 함
- 잘못된 직렬화 형태를 선택하면
  - 해당 클래스의 **복잡성**과 **성능**에 영구적으로 **부정적**인 영향