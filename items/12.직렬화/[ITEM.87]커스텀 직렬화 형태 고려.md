## [ITEM.87] 커스텀 직렬화 형태 고려

### 선 작업 후 유지보수 전략 - Serializable
- 어떤 기능을 만들 때,
  - 다음 릴리스에서 제대로 다시 구현하기로 하고,
  - 이번 릴리스에서는 동작만 하도록 하는 것
- 보통은 크게 문제되지 않으나,
  - 클래스가 `Serializable`을 구현하고, **기본 직렬화 형태**를 사용한다면,
    - 다음 릴리스때 **기본 직렬화 형태**를 버릴 수 없게 된다.
- 다음 릴리스 때 버리려 한 현재의 구현에
  - 영원히 종속되는 형태
  - 기본 직렬화를 버릴 수 없음
- 실제로도 `BigInteger`와 같은
  - 일부 자바 클래스가 가지고 있는 문제

### 괜찮을 때만 기본 직렬화 형태 사용
- 고민 이후, 괜찮다고 판단될때만,
  - **기본 직렬화 형태**를 사용할 것
- **기본 직렬화 형태**는
  - **유연성**, **성능**, **정확성** 측면에서
    - 신중히 고민한 후, 합당할때만 사용해야 함
- 일반적으로, 직접 설계하더라도,
  - **기본 직렬화 형태와 같은 결과**가 나올 때만, 기본 형태를 사용해야 함
- 어떤 객체의 **기본 직렬화 형태**는
  - 그 객체를 `root`로 하는 객체 그래프의 **물리적 모습**을
  - 나름 효율적으로 인코딩 한다.
- 객체가 포함된 **데이터**들과
  - 그 객체에서부터 시작해 **접근할 수 있는 모든 객체**를 담고,
  - 심지어, 이 객체들이 연결된 `topology`(위상)까지 기술
- 아쉽게도, **이상적인 직렬화 형태**라면
  - **물리적인 모습**과 **논리적인 모습**만을 표현해야 함

### 객체의 물리적 표현과 논리적 내용이 동일 할 때
- 객체의 **물리적 표현**과 **논리적 내용**이 같다면,
  - **기본 직렬화 형태**를 써도 무방
- 기본 직렬화에 이상적인 코드
  ```java
  public class Name implements Serializable {

    /**
      * 성, null이 아니어야 함
      * @serial
      **/
    private final String lastName;

    /**
      * 이름, null이 아니어야 함
      * @serial
      **/
    private final String firstName;

    /**
      * 중간이름, 중간 이름이 없다면 null
      * @serial
      **/
    private final String middleName;
    ...
  }
  ```
- 이름은 논리적으로 `이름`, `성`, `중간이름`이라는 `3개의 문자열`로 구성되며,
  - 앞 코드의 **인스턴스 필드**는 위 논리적 구조를 정확히 반영함

### readObject의 사용
- **기본 직렬화 형태**가 적합하다고 결정했더라도,
  - **불변식 보장**과 **보안**을 위해 `readObject` 메서드를 제공할 때가 많음
- 앞의 `Name` 클래스의 경우,
  - `readObject` 메서드가, `lastName`과 `firstName` 필드가 `null`이 아님을 보장해야 함
- ITEM.88, ITEM.90

### 문서화 주석
- `Name`의 세 필드 모두 `private`임에도 **문서화 주석**이 달려있음
- 클래스의 **직렬화 형태**에 포함되는 **공개 API**에 속하며,
  - 공개 API는 모두 문서화 해야하기 때문
- `private` 필드의 설명을 **API 문서**에 포함하라고 javadoc에 알려주는 역할은
  - `@serial` 태그
- `@serial` 태그로 기술한 내용은
  - API 문서에서 **직렬화 형태**를 설명하는 특별한 페이지에 기록됨

### 직렬화에 적합하지 않은 예
- 문자열 리스트를 표현
  - 물론 `List` 구현체를 사용하면 더 이상적으로 표현은 가능하나, 여기서는 논외
- 코드
  ```java
  public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;

    private static class Entry implements Serializable {
      String data;
      Entry next;
      Entry previous;
    }
    // ... 나머지 코드 생략
  }
  ```
- 논리적으로 위 클래스는 `일련의 문자열`을 표현
- 물리적으로는 **문자열**들을 **이중 연결 리스트**로 표현
- 이 클래스에, **기본 직렬화 형태**를 사용하면
  - 각 노드의 양방향 연결정보를 포함해
  - 모든 `Entry`를 철두철미하게 기록해야 함