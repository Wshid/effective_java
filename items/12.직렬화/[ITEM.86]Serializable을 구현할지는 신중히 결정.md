## [ITEM.86] Serializable을 구현할지는 신중히 결정

### 인스턴스 직렬화
- 어떤 클래스의 **인스턴스를 직렬화**할 수 있게 하려면
  - 클래스 선언에 `implements Serializable`을 붙이면 됨
- 쉽게 적용이 가능하지만
  - 신경써야할 부분
- 직렬화를 지원하도록 설정하는 것은 쉬우나
  - 비용이 큰 작업

### Serializable 구현시 단점 - 릴리스 이후
- `Serializable`을 구현하면, 릴리스 이후 **수정하기 어려움**
- 클래스가 `Serializable`을 구현하면
  - **직렬화된 바이트 스트림 인코딩**(직렬화 형태)도 하나의 **공개 API**가 된다.
- 이 클래스가 널리 퍼질 경우,
  - 그 **직렬화 형태**도 다른 공개 API와 마찬가지로, **영원히 지원**해야 함
- **커스텀 직렬화 형태**를 설계하지 않고, **자바의 기본 방식**을 사용할 경우,
  - 직렬화 형태는 **최소 적용 당시 클래스**의 내부 구현 방식에 귀속
- 직렬화 형태에서는
  - 클래스의 `private`과 `package-private` **인스턴스 필드**들마저 API 형태로 **공개**됨
    - **캡슐화가 깨진다**
  - 필드로의 접근을 최대한 막아, **정보 은닉**이 무력화(ITEM.15)

### 직렬화 가능 클래스 생성시 유의점
- 클래스 내부 구현을 보면, 원래의 **직렬화 형태와 다름**
- 한쪽은 **구버전 인스턴스**를 직렬화하고,
  - 다른쪽은 **신버전 인스턴스**로 **역직렬화**한다면, 실패 발생
- `ObjetctOutputStream.putFields`와 `ObjectInputStream.readFields`를 이요하면
  - 원래의 **직렬화 형태**를 유지하면서, **내부 표현**을 변경할 수 있으나,
    - 어려우며, 소스가 지저분해짐
- **직렬화 가능 클래스**를 만들고자 한다면,
  - 길게 보고, 감당할 수 있을 만큼
  - **고품질의 직렬화 형태**도 주의하여 함께 설계해야함(ITEM.87, ITEM.90)
- 초기 개발 비용은 높아지나, 그만큼의 보상이 따를 것
- 직렬화 형태를 잘 설계하더라도,
  - **클래스 개선 제약**이 생길 수 있음

### Serialize 구현의 문제 - Serial version UID
- 스트림 고유 식별자, **직렬 버전 UID**(serial version UID)
- 모든 직렬화된 클래스는, **고유 식별 번호**를 부여받음
  - `serialVersionUID`라는 `static final long` 필드로,
  - 이 번호를 명시하지 않을경우,
    - 시스템이 **Runtime**에 **암호 해시 함수**(SHA-1)을 적용하여
    - 자동으로 클래스 안에 생성해서 넣게됨
- **직렬 버전 UID** 생성시 고려되는 사항
  - **클래스 이름**
  - **구현한 인터페이스**
  - 컴파일러가 자동으로 생성해 넣은 것을 포함한 **대부분의 클래스 멤버**
- 나중에 **편의 메서드**를 추가하는 식으로, 이들 중 하나라도 수정한다면
  - **직렬버전 UID**값도 변할 수 있음
- 자동 생성되는 값에 의존하면, **호환성이 깨진다**
  - **Runtime**에 `InvalidCalssException`이 발생

### Serialize 구현의 문제 - 버그
- 버그와 보안 구멍이 생길 위험이 높아짐(ITEM.85)
- 객체는 **생성자**를 사용해 만드는게 기본적
- **직렬화**는 **언어의 기본 매커니즘**을 **우회**하는 객체 생성 기법
- 기본 방식을 따르든, 재정의해서 사용하든
  - **역직렬화**는 **일반 생성자**의 문제가 그대로 적용되는 **숨은 생성자**
- 이 생성자는 **전면에 드러나지 않음**, 따라서 다음과 같은 유의사항을 확인하기 어려움
  - 생성자에서 구축한 **불변식**을 모두 보장해야 하며,
  - 생성 도중, 공격자가 객체 내부를 들여다 볼 수 없어야 함
- 기본 **역직렬화**를 사용하면
  - **불변식 깨짐**과 **허가되지 않은 접근**에 쉽게 노출될 수 있음

### Serialize 구현의 문제 - 신버전 릴리스
- 해당 클래스의 **신버전**을 릴리스할 때, **테스트** 할 것이 많아짐
- 직렬화 가능 클래스가 수정되면, 다음과 같은 사항을 검증해야 함
  - **신버전 인스턴스**를 직렬화한 후, 구버전으로 **역직렬화**가능한지,
  - 그 반대도 가능한지
- 테스트해야 할 양이
  - **직렬화 가능 클래스**의 수
  - **릴리스 횟수**에 비례해 증가한다.
- 양방향 **직렬화/역직렬화**가 모두 성공하고,
  - 원래의 객체를 **충분히 복제해내는지**를 반드시 확인해야 함
- 클래스를 제작할 때, **커스텀 직렬화 형태**를 잘 설계했을 경우
  - 테스트 부담을 줄일 수 있음(ITEM.87, ITEM.90)

### Serialize 구현여부의 판단
- 가볍게 결정할 수 있는 사안이 아님
- 단, 객체를 **전송/저장**할 때, 
  - **자바 직렬화를 이용하는 프레임워크용**으로 만든 클래스라면, 선택의 여지가 없음
- `Serializable`을 반드시 구현하는 클래스의 **컴포넌트**로 쓰일 클래스도 마찬가지
- 하지만, `Serializable` 구현에 따르는 비용이 적지 않으니,
  - 클래스를 설계할때마다, 그 **이득**과 **비용**을 잘 저울질 해야 함
- 역사적으로 `BigInteger`와 `Instant` 같은 **값** 클래스와, **컬렉션 클래스**들은 
  - `Serializable`을 구현하고,
- 스레드 풀처럼 **동작**하는 객체를 표현하는 클래스들은,
  - 대부분 `Serializable`을 **구현하지 않음**

### 상속용으로 설계된 클래스와 Serializable
- **상속용으로 설계된 클래스**(ITEM.19)는 대부분 `Serializable`을 구현하면 X
  - 그 인터페이스도 대부분 `Serializable`을 확장해서는 X
- 이 규칙을 따르지 않으면,
  - 그런 클래스를 확장하거나, 그런 인터페이스를 구현하는 이에게
    - **커다란 부담**이 될 수 있음
- 이 규칙을 어겨야하는 상황
  - `Serializable`을 구현한 클래스만 지원하는 **프레임워크**를 사용하는 상황이라면
  - 방법이 없음

### 상속용으로 설계된 클래스와 Serializable - 예시
- `Throwable`과 `Component`
- `Throwable`은
  - 서버가 **RMI**를 통해 C로 예외를 보내기 위해 `Serializable`을 구현
- `Component`는
  - `GUI`를 전송하고, 저장하고 복원하기 위해 `Serializable`을 구현했지만
  - `Swing`과 `AWT`가 널리 쓰이던 시절에서도
    - 현업에서 이 용도로 많이 사용되지 않음

### 인스턴스 필드 직렬화시 주의할 점
- 인스턴스 필드값 중 **불변식**을 보장할 게 있다면
  - 반드시 **하위 클래스**에서 `finalize` 메서드르 **재정의**하지 못하게 해야 함
  - `finalize` 메서드를 **자신이 재정의**하면서 `final`로 선언하면 됨
  - 이렇게 하지 않을경우 `finalizer` 공격(ITEM.8)을 당할 수 있음
- 인스턴스 필드 중 **기본값**(정수형은 0, `boolean`은 `false`, 객체 참조는 `null`)으로 초기화되면
  - 위배되는 **불변식**이 있다면
  - 클래스에 다음의 `readObjectNoData` 메서드를 꼭 추가해야 함
- `readObjectNoData` 메서드
  ```java
  private void readObejctNoData() throws InvalidObjectExcetion {
    throw new InvalidObjectException("스트림 데이터가 필요");
  }
  ```
- 위 메서드는 `java 4`에 추가되었으며,
  - 기존의 **직렬화 가능 클래스**에
  - **직렬화 가능 상위 클래스**를 추가하는
    - 드문 경우를 위한 메서드

### Serializable을 구현하지 않을 때 주의할 점
- **상속용 클래스**인데 직렬화를 지원하지 않으면,
  - 그 **하위 클래스**에서 **직렬화**를 지원하려 할 때, 부담이 늘어남
- 보통은 이런 클래스를 **역직렬화**하려면
  - 그 상위 클래스는 **매개변수 없는 생성자**를 제공해야 함
  - 이런 생성자를 제공하지 않으면,
    - 하위 클래스는 어쩔 수 없이 **직렬화 프록시 패턴**(ITEM.90)을 사용해야 함

### 내부 클래스는 직렬화 하지 말 것
- 내부 클래스(ITEM.24)는 직렬화를 하지 말아야 함
- 내부 클래스에는
  - **바깥 인스턴스**의 참조와 유효범위 안의 **지역변수 값**들을 저장하기 위해
  - **컴파일러**가 생성한 **필드**들이 자동으로 추가됨
- **익명 클래스**와 **지역 클래스**의
  - 이름을 짓는 규칙이 **언어 명세**에 나와 있지 않듯,
  - **이 필드들의 클래스 정의**에 어떻게 추가되는지도 정의되지 않음
- **내부 클래스**에 대한 기본 직렬화 형태는 분명하지 않음
- **정적 멤버 클래스**는 `Serializable`을 구현해도 됨

### 핵심 정리
- `Serializable`을 구현한다고 선언하기는 쉽지만, 따르는 대가는 크다
- 보호된 환경에서만 쓰일 클래스가 아니라면, `Serializable` 구현은 아주 신중해야 함
  - 한 클래스의 **여러 버전**이 상호작용할 일이 없음
  - 서버가 신뢰할 수 없는 데이터에 노출될 가능성
- 상속할 수 있는 클래스라면 **주의사항**이 더 많아짐
  