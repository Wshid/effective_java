## [ITEM.17] 변경 가능성 최소화
- 불변 클래스
    - 인스턴스 내부 값을 수정할 수 없는 클래스
- 불변 인스턴스에 간직된 정보는 고정 됨
    - 객체가 파괴되는 순간까지 절대 달라지지 않음
- JPL의 불변 클래 스
    - String
    - 기본 타입의 Boxing Class
    - BigInteger
    - BigDecimal
- 불변 클래스의 장점
    - 가변클래스보다 설계하고 구현하기 쉬움
    - 오류가 생길 여지가 적음

### 클래스를 불변으로 만들기 위한 규칙(5)
- 객체의 상태를 변경하는 메서드 제공 x
- 클래스 확장할 수 없도록 제어
    - 하위 클래스에서 객체의 상태를 변경할 수 없도록 함
    - 상속을 막는 대표적인 방법?
        - `final`로 선언
- 모든 필드를 `final`로
    - 설계자의 의도를 명확히 드러내는 방법
    - 새로 생성된 `instance`를 `동기화 없이`
        - 다른 `thread`로 건네도 문제없이 동작하게끔 보장하는데도 필요
    - 자바 언어 명세의 메모리모델 부분(JLS, 17.5; Geotz06, 16)에 자세히 설명
- 모든 필드를 `private`로
    - 필드가 참조하는 `가변 객체`를
        - C에서 직접 접근해 수정하는 일을 막는다.
    - `기본 타입 필드`나 `불변 객체를 참조하는 필드`를
        - `public final`로만 선언해도 불변 객체가 됨
        - 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권하지는 않음
- 자신 외에는 `내부의 가변 컴포넌트`에 접근할 수 없도록 함
    - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면
        - C에서 객체의 참조를 얻을 수 없도록 해야 함
    - 이런 필드는 절대 C가 제공한 객체 참조를 가리키게 하면 안 됨
        - 접근자 메서드가 필드를 반환 X
    - `생성자`, `접근자`, `readObject 메서드(ITEM. 88)` 모두에서 방어적 복사를 시도해야 함

### 복소수 클래스 예제
>```
>public final class Complex {
>    private final double re;
>    private final double im;
>    ...
>
>    public Complex plus(Complex c){
>        return new Complex(re + c.re, im + c.im);
>    }
>    ...
>}
>```
- 사칙연산 메서드에서 인스턴스 자신을 수정하는 것이 아닌
    - 새로운 `Complex`인스턴스를 리턴
- 함수형 프로그래밍
    - 피연산자에 함수를 적용에 그 결과를 반환하나,
    - 피연산자 자체는 그대로인 프로그래밍 패턴
    - 상태가 변하지 않는다.
- 절차형, 명령형 프로그래밍 에서는
    - 메서드에서 피연산자인 자신을 수정하여
    - 상태가 변하게 된다.
- 메서드 이름으로 `add`와 같은 동사가 아닌 `plus`와 같은 전치사 사용
    - 해당 메서드가 값을 변경하지 않는다는 사실 강조
- `BigInteger`, `BigDecimal` 클래스가 이를 따르지 않음
    - 오류가 발생한다.

### 함수형 프로그래밍(불변 객체)의 장점
- 불변 객체는 단순함
    - 객체 생성, 파괴 시점의 데이터가 동일함
    - 모든 생성자가 `class invariant`(클래스 불변식)을 보장하면,
        - 타 작업 없이 영원히 불변으로 사용 가능
    - 가변 객체의 경우 복잡한 상태에 놓일 수 있음
- thread-safe
    - 따로 동기화 할 필요가 없음
    - 여러 쓰레드가 동시에 사용해도 훼손되지 않음
    - 클래스를 thread-safe하게 만드는 쉬분 방식중 하나
    - 불변 클래스라면, 한번 만든 instance를 최대한 재활용 하는게 좋음
    - 가장 쉬운 재활용 방법?
        - 자주 쓰이는 값들을 상수(`public static final`)로 선언하는 것
        >```
        >public static final Complex ZERO = new Complex(0, 0);
        >```

### 불변 객체의 특징
- 자주 사용되는 인스턴스를 캐싱하여
    - 인스턴스를 중복 생성하지 않게 해주는 `정적 팩터리`(ITEM.1) 제공 가능
        - 박싱된 기본 타입 클래스
        - BigInteger가 속함
- 정적 팩터리를 사용하면
    - 여러 C가 instance를 공유하여 `메모리 사용량`, `GC 비용`이 줄어든다.
- 새로운 클래스 생성시,
    - `public` 생성자 대신, 정적 팩터리 사용한다면
    - C가 수정 없이 필요에 따라 캐시 기능 추가 가능
- 방어적 복사(ITEM.50)
    - 불변 객체, 자유롭게 공유 가능 -> 방어적 복사
    - 아무리 복사해도 결국 원본과 같다는 의미
        - 복사가 의미 없음
- 불변 클래스는 `clone`메서드나, `복사 생성자(ITEM.13)`를 제공하지 말아야 함
    - `String` 클래스의 복사 생성자는 되도록 사용하지 말 것
- 불변 객체는 `자유 공유` 가능 / 불변 객체 `끼리의 내부 데이터` 공유 가능
    - `BigInteger`
        - 부호(sign), 크기(magnitude)를 따로 표기
            - `int sign`, `int[] magnitude`
        - `negate`메서드
            - 부호가 반대인 새로운 `BigInteger` 객체 생성
            - 배열 복사 없이, 원본 인스턴스의 값 사용
            - 새로 만든 `BigInteger` 인스턴스도
                - 원본 인스턴스의 내부 배열을 가리킴
- 객체를 만들때 타 불변 객체 사용시의 이점
    - 값이 바뀌지 않는 구성요소일수록,
        - 구조가 복잡해도 불변식 유지가 쉬움
    - 불변 객체는 `Map`의 키, `Set`의 원소로 사용하기 좋음
        - 불변 객체 사용시 값의 변경이 일어나지 않기 때문
- 불변 객체는 그 자체로 `failure atomicity`(ITEM.76)를 지원함
    - 상태가 변하지 않으므로, 불일치 상태에 빠질 가능성이 없음

### 불변 클래스의 단점
- 값이 다르면 반드시 독립된 객체로 만들어야 함
- 백만 비트로 이루어진 BigInteger에서 비트 하나를 바꾼다고 하면,
    >```
    >BigInteger moby = ...;
    >moby = moby.flipBit(0);
    >```
    - `flipBit`은 새로운 `BigInteger` 인스턴스 생성
    - 원본과 한 비트만 달라도 생성해야 함
- `BitSet`
    - 비트 순열을 표현한다
    - `BigInteger`와 달리 가변
    >```
    >BitSet moby = ...;
    >moby.flip(0);
    >```
- 원하는 객체를 만들기 위한 단계가 많고,
    - 중간 단계에서 만들어진 객체가 버려진다면
        - 성능문제가 당연히 커짐

### 단점 해결 방법 두가지
- 다단계 연산(multistep operation)을 예측하여 기본기능으로 제공
    - 흔히 쓰일 연산을 지정
    - 각 단계마다 객체를 생성하지 않아도 됨
    - `BigInteger`의 경우
        - `모듈러 지수`와 같은 다단계 연산 속도를 높여주는
            - 가변 동반 클래스(`companion class`)를 `package-private`로 제공
- C가 원하는 복잡한 연산을 정확히 에측할 수 있다면,
    `package-private`의 가변 동반 클래스로만으로 충분함
- 그게 아니라면, 해당 클래스를 `public`으로 제공해야 함
    - `String` 클래스의 가변동반 클래스 => `StringBuiler, StringBuffer(prev ver.)`

### 불변 클래스를 만드는 설계 방법
- 클래스가 불변임을 보장하려면
    - 자신을 `상속하지 못하게` 해야 함
- `final` : 상속을 못하게 하는 가장 쉬운 방법
- 또는, 모든 생성자를 `private`, `package-private`으로 만들고,
    `public` 정적 팩터리를 제공하는 방법
- Complex 예시
    >```
    >public class Complex {
    >    private final double re;
    >    private final double im;
    >
    >    private Complex(double re, double im){...}
    >    public static Complex valueOf(double re, double im){
    >        return new complex(re, im);
    >    }
    >}
    >```
- 밖에서 확인 불가능한 `package-private` 구현 클래스를 원하는 만큼 만들어 활용 가능
    - 패키지 외부에서의 이 Complex 객체는 사실상 `final`임
    - `public`이나 `protected` 생성자가 없으니, 다른 패키지에서는 이 클래스 확장이 불가능 함
- 정적 팩터리 방식은
    - 다수의 구현 클래스를 활용한 유연성 제공
    - 객체 캐싱 기능을 추가해 성능 향상 가능

### BigInteger, BigDecimal 사용시 주의점
- 두 클래스의 메서드들은 재정의가 가능하게 설계됨
- 해당 인스턴스를 인수로 받을 때 조심해야함
- 인수로 받은 객체가 진짜 `BigInteger/BigDecimal`인지 확인해야 함
- 신뢰할 수 없는 하위 클래스의 인스턴스 일시,
    - 해당 인수들은 가변이라 가정, 방어적으로 복사해야 함
    >```
    >public static BigInteger safeInstance(BigInteger val) {
    >    return val.getClass() == BigInteger.class ?
    >        val : new BigInteger(val.toByteArray());
    >}
    >```

### 규칙 완화
- 모든 필드가 `final`이고, 어떤 메서드도 그 객체를 수정할 수 없어야 한다는 규칙
    - 성능을 위해 조금 완화 한다면,
- 어떤 메서드도 객체의 상태중 `외부에 비치는 값`을 변경할 수 없음
- 어떤 불변 클래스는 계산 비용이 큰 값을
    - 나중에(처음쓸 떄) 계산하여
        - `final`이 아닌 필드에 캐싱하여 사용하기도 한다.
- 재요청시, 캐시해둔 값을 사용한다.
    - 해당 객체가 불변이기 때문에 사용 가능한 방법

### 직렬화시 주의점
- `Serializable`을 구현하는 불변 클래스 내부에,
    - 가변 객체를 참조하는 필드가 있다면
        - `readObject`, `readResolve` 메서드를 반드시 제공하거나,
        - `ObjectOutputStream.writeUnshared`와 `ObjectInputStream.readUnshared` 메서드 사용 필요
    - 플랫폼이 제공하는 기본 직렬화 방법이면 충분해도 구현해야 함
    - 공격자가 이 클래스로부터 가변 인스턴스를 만들어 낼 가능성 존재
        - `ITEM.88`

### 정리
- `getter`가 있다고 해서, 무조건 `setter`를 만들지 말 것
- 클래스는 꼭 필요한 경우가 아니라면 불변 이어야 함
- 불변 클래스는 장점이 많음. 잠재적 성능 저하 존재
- 단순 값 객체는 불변으로 만들기
    - `PhoneNumber`, `Complex` 등
- `String`, `BigInteger`와 같은 무거운 값 객체도
    - 불변으로 만들 수 있을지 고려해야 함
- 성능 때문에 어쩔 수 없을 경우,
    - 불변 클래스와 쌍을 이루는, `가변 동반 클래스`를 `public`으로 제공하기
- 모든 클래스를 불변으로 만들수 없기에,
    - 변경할 수 있는 부분을 최소한으로 줄이기
        - 예측이 쉬워지고, 오류 가능성이 낮아짐
- 꼭 변경해야할 필드 외에 `final`로 선언
- **다른 이유가 없다면, 모든 필드는 `public final`이어야 한다**
- `생성자`는 `불변식 설정`이 모두 완료된,
    - 초기화가 완벽히 끝난 객체를 생성해야 함
    - 생성자와 정적 팩터리 외에는 어떤 초기화 메서드도 `public`으로 제공하면 안됨
        - 객체를 재활용할 목적으로, 상태를 초기화하는 메서드도 마찬가지
        - 복잡성만 높아지고, 성능 개선점은 낮음
            - `java.util.concurrent.CountDownLatch` 클래스가 이에 해당
                - 가변 클래스이지만, 가질 수 있는 상태 수는 많지 않으며,
                - 인스턴스 생성 후 한번 사용하고 나면 끝