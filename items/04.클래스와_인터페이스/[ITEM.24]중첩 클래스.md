## [ITEM.24] 중첩 클래스
### 중첩 클래스(nested class)
- 다른 클래스 내부에 정의된 클래스
- 자신을 감싸고 있는 바깥 클래스에서만 사용 되어야 함
- 그 이외의 쓰임새가 있을 경우,
    - 톱레벨 클래스로 만들어야 함

### 중첩 클래스의 종류(4)
- 외부 클래스
    - 정적 멤버 클래스
- 내부 클래스
    - (비정적) 멤버 클래스
    - 익명 클래스
    - 지역 클래스

### 정적 멤버 클래스
- 다른 클래스 안에 선언
- 바깥 클래스의 `private` 멤버에도 접근이 가능함
    - 일반 클래스와 의 다른 점
- 다른 정적 멤버와 같은 접근 규칙을 가짐
    - `private`으로 선언시, 바깥 클래스에서만 접근 가능
- 흔히 바깥 클래스와 함께 쓰일때만 유용한
    - `public 도우미 클래스`로 사용 됨
    - ex) 계산기가 지원하는 열거 타입
        - `Operation` Enum의 경우
            - `Calculator` 클래스의 `public` 정적 멤버 클래스가 되어야 함
        - `Calculator.Operation.PLUS`, `Calculator.Operation.MINUS`와 같이 참조 가능

### 비정적 멤버 클래스
- 구문상 `static`이 붙지 않음
- 바깥 클래스의 `인스턴스`와 `암묵적`으로 연결 됨
- 비정적 멤버 클래스의 `instance` 메서드에서
    - 정규화된 `this`를 사용해(`ClassName.this`)
        - 바깥 인스턴스의 메서드를 호출하거나
        - 바깥 인스턴스의 참조를 가져올 수 있음
- 중첩 클래스의 인스턴스가
    - 바깥 인스턴스와 독립적으로 존재 가능하다면,
    - **정적 멤버 클래스**로 만들어야 한다.
- 비정적 멤버 클래스는
    - **바깥 인스턴스 없이 생성 불가능**
- **어댑터**를 정의할 때 자주 쓰임
    - 어떤 클래스의 인스턴스를 감싸
    - 마치 `다른 클래스의 인스턴스처럼` 보이게 **뷰**로 활용
- `Map` 인터페이스의 구현체(`KeySet, entrySet, values 메서드의 반환)들은
    - 자신의 컬렉션 뷰를 구현할 때, 비정적 멤버 클래스를 사용한다.
    - `Set`과 `List`도 마찬가지
- 자신의 반복자 구현 예시
    >```
    >public class MySet<E> extends AbstractSet<E> {
    >    ...
    >
    >    @Override public Iterator<E> iterator() {
    >        return new MyIterator();
    >    }
    >
    >    // 비정적 멤버 클래스
    >    private class MyIterator implements Iterator<E> {
    >        ...
    >    }
    >}
    >```
- `멤버 클래스`에서
    - `바깥 인스턴스`에 접근할 일이 없다면,
    - `static`을 붙여서 `정적 멤버 클래스`로 사용하기
- `static`을 생략하면,
    - 바깥 인스턴스의 **숨은 외부 참조**를 가지게 됨
- 이 참조를 사용하기 위해 **시간**과 **공간**이 낭비 됨
- **GC**가 바깥 클래스의 `instance`를 수거하지 못해,
    - **메모리 누수**가 발생할 수 있다.
    - 참조가 눈에 보이지 않기 때문에, 원인 파악도 어려움

### 비정적 멤버 클래스의 인스턴스 - 바깥 클래스 인스턴스
- 둘의 관계는
    - `멤버 클래스`가 `인스턴스화` 될 때 정의 됨
    - 더 이상 `변경이 불가능` 함
- `바깥 클래스`의 `인스턴스 메서드`에서
    - `비정적 멤버클래스`의 `생성자` 호출시 자동으로 만들어진다.(보통의 경우)
    - `바깥 인스턴스의 클래스.new MemberClass(args)`로 수동 생성도 가능함
- 이 관계에 따라
    - 비정적 멤버 클래스의 인스턴스 안에 만들어져
    - **메모리 공간을 차지함**
    - 생성 시간도 더 오래걸림

### private 정적 멤버 클래스
- `바깥 클래스`가 표현하는 `객체의 한 부분(구성요소)`를 나타낼때 사용
- `Map`인스턴스 예시
    - Map 구현체는, 각각의 key-value를 나타내는 `Entry` 객체를 가짐
    - 모든 `Entry`가 맵과 연관되어 있으나,
        - 엔트리의 메서드(`getKey`, `getValue`, ...)는 `Map`을 직접 사용하지 X
    - `Entry`를 비정적 멤버 클래스로 선언하지 않음
    - `private 정적 멤버 클래스`가 제일 적당함
- `Entry`선언시 `static`을 빠뜨려도 동작은 하나,
    - 모든 엔트리가 바깥 맵으로 참조를 가지기 때문에
    - **공간**과 **시간**이 낭비됨

### 중요한 점
- **멤버 클래스**가 **공개된 클래스**의
    - `public`/`protected` 멤버일 경우,
    - `static`여부는 더 중요
- `멤버 클래스` 역시 `공개 API`가 되기 때문에
    - 향후 `static`을 붙이면 하위 호환성이 깨진다.

### 익명 클래스
- 이름이 없는 클래스
- 바깥 클래스의 멤버도 아님
- **쓰이는 시점에 선언과 동시에 인스턴스 생성**
- 어디서든 생성 가능
- `비정적인 문맥`에서 사용될 때만
    - `바깥 클래스의 인스턴스` 사용 가능
- `정적 문맥`에서라도
    - 상수 변수 이외의 정적 멤버를 가질 수 없음
    - 상수 표현을 위해
        - `초기화된 final 기본 타입`과 `문자열 필드`만 가질 수 있다.
- 응용하는데 제약이 많다
    - 선언 시점에서만 **인스턴스** 생성 가능
    - `instanceof` 검사나, 클래스의 이름이 필요한 작업
        - 수행 불가
    - 익명 클래스를 사용하는 C는
        - `익명 클래스`가 상위 타입에서 `상속한 멤버` 외에 호출 불가
    - 익명 클래스는 표현식 중간에 등장
        - 짧지 않으면, 가독성을 해친다.
- java의 `lambda`지원 전까지
    - 작은 함수객체, 처리 객체를 만드는데 **익명 클래스** 사용
- `정적 팩터리 메서드 구현`시 사용됨

### 지역 클래스
- 가장 드문 사용
- `지역변수`를 선언할 수 있는 곳 어디든 선언 가능
- `유효 범위`도 `지역변수`와 동일
- `멤버클래스` 처럼
    - `이름`이 있으며, `반복 사용`이 가능
- `익명클래스` 처럼
    - `비정적 문맥에서 사용`될 때만
        - `바깥 인스턴스` 참조 가능
    - `정적 멤버`는 가질 수 없음
    - `가독성`을 위해 짧게 작성


### 결론
- 중첩클래스의 4가지 종류, 각자의 쓰임이 다름
- 멤버 클래스
    - 메서드 밖에서 사용해야 할때
    - 메서드 안에 정의하기에 너무 길 때
- 멤버 클래스의 인스턴스 각각이, `바깥 인스턴스 참조`시
    - `비정적(non-static)`
    - 아니라면 `정적(static)`
- 익명 클래스
    - 중첩 클래스가 `한 메서드 안`에서만 쓰일 때
    - `인스턴스 생성지점`이 `하나` 일때
    - 해당 타입으로 적합한 `클래스/인터페이스`가 있을 때
- 지역 클래스
    - 위의 3가지 익명클래스 해당 사항이 없을 때